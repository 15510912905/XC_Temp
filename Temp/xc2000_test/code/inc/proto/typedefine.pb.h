// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: typedefine.proto

#ifndef PROTOBUF_typedefine_2eproto__INCLUDED
#define PROTOBUF_typedefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_typedefine_2eproto();
void protobuf_AssignDesc_typedefine_2eproto();
void protobuf_ShutdownFile_typedefine_2eproto();


enum MsgType {
  MSG_ReqReset = 2001,
  MSG_ResReset = 2002,
  MSG_ReqAddTask = 2003,
  MSG_ResAddTask = 2004,
  MSG_NotifyMachineStatus = 2005,
  MSG_NotifyRctCupStatus = 2006,
  MSG_ReqMarginScan = 2007,
  MSG_ResMarginScan = 2008,
  MSG_ReqBarcodeScan = 2009,
  MSG_ResBarcodeScan = 2010,
  MSG_ReqAirOut = 2011,
  MSG_NotifyTimer = 2012,
  MSG_ReqReagentSuspend = 2013,
  MSG_AckTaskResult = 2014,
  MSG_ReqIntensifyWash = 2015,
  MSG_NotifyReportResult = 2016,
  MSG_NotifyReagInfo = 2017,
  MSG_WriteLog = 2018,
  MSG_NotifyADValue = 2019,
  MSG_NotifyConnect = 2020,
  MSG_ReqHello = 2021,
  MSG_ResHello = 2022,
  MSG_ReqActCmd = 2023,
  MSG_NotifyOffset = 2024,
  MSG_ReqStopMach = 2025,
  MSG_ReqPreciseAdd = 2026,
  MSG_ReqLightCheck = 2027,
  MSG_ReqCupBlank = 2028,
  MSG_ReqWashReactCup = 2029,
  MSG_ReqSetTime = 2030,
  MSG_ReqDarkCurrent = 2032,
  MSG_ResDarkCurrent = 2033,
  MSG_NotifyTemp = 2035,
  MSG_GetMidLog = 2036,
  MSG_CollideNdlConfig = 2037,
  MSG_GetVres = 2038,
  MSG_ResVres = 2039,
  MSG_NotifyFailedSmpTask = 2040,
  MSG_ReqCompBack = 2041,
  MSG_ResCompBack = 2042,
  MSG_ReqCompRecover = 2043,
  MSG_ResCompRecover = 2044,
  MSG_NotifyAlarm = 2045,
  MSG_NotifySynAlarm = 2046,
  MSG_ReqDeleteAlarm = 2047,
  MSG_NotifySendTask = 2049,
  MSG_TempeQuery = 2050,
  MSG_UpdateDwn = 2051,
  MSG_ReqSmoothAreaTest = 2052,
  MSG_ResSmoothAreaTest = 2053,
  MSG_ReqShowWave = 2054,
  MSG_ResShowWave = 2055,
  MSG_ReqConnectPort = 2056,
  MSG_ADtest = 2057,
  MSG_NotifyMotor = 2058,
  MSG_ReqBackupMotor = 2059,
  MSG_ResBackupMotor = 2060,
  MSG_ReqRecoverMotor = 2061,
  MSG_ReqRegPollution = 2062,
  MSG_ReqSmpPollution = 2063,
  MSG_ReqBeepAlarm = 2064,
  MSG_ReqRctPollution = 2065,
  MSG_Consume = 2066,
  MSG_CPUID = 2067,
  MSG_ReqShelf = 2068,
  MSG_ResShelf = 2069,
  MSG_SetShelf = 2070,
  MSG_NotifyState = 2071,
  MSG_FreeShelf = 2072,
  MSG_NotifySmpFrameStatus = 2073,
  MSG_NotifyReagChange = 2074,
  MSG_ReqShowAD = 3010,
  MSG_ResShowAD = 3011,
  MSG_FLXQuery = 3012,
  MSG_ReqReadDarkCurrent = 3013,
  MSG_ResReadDarkCurrent = 3014,
  MSG_NotifyTestingADValue = 3015,
  MSG_ReqSkipCup = 3016,
  MSG_SetSleep = 3017,
  MSG_NotifySound = 3018,
  MSG_CfgAlarmSound = 3019,
  MSG_ReqBeepPlay = 3020,
  MSG_TestOver = 3021,
  MSG_BloodAbsorb = 3022,
  MSG_TempPara = 3023,
  MSG_AutoloadDebug = 3024,
  MSG_AutoLoadStatus = 3025,
  MSG_ReqAutoPowerOn = 3036,
  MSG_ReqAutoPowerOnInfo = 3037,
  MSG_ResAutoPowerOnInfo = 3038
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_ReqReset;
const MsgType MsgType_MAX = MSG_ResAutoPowerOnInfo;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum ActType {
  Act_Reset = 0,
  Act_Move = 1,
  Act_Absorb = 2,
  Act_Discharge = 3,
  Act_Wash = 4,
  Act_AirOut = 5,
  Act_Mix = 6,
  Act_IntensifyWash = 7,
  Act_BcScan = 8,
  Act_DwnQuery = 9,
  Act_TrimOffset = 10,
  Act_SaveOffset = 11,
  Act_NdlVrt = 12,
  Act_Light = 13,
  Act_Ad = 14,
  Act_DskHrotate = 15,
  Act_MarginScan = 16,
  Act_TempSwitch = 17,
  Act_Fault = 18,
  Act_Debug = 19,
  Act_TempQuery = 20,
  Act_CtrlP04 = 21,
  Act_MidState = 22,
  Act_PVCtrl = 23,
  Act_PumpCtrl = 24,
  Act_LiquidsCheck = 25,
  Act_CoolingCtrl = 26,
  Act_BBClear = 27,
  Act_SmpLightCtrl = 28,
  Act_UpdateDwn = 29,
  Act_OlnyMix = 30,
  Act_Showave = 31,
  Act_LiquidDBG = 32,
  Act_SetFlState = 33,
  Act_WriteMotor = 34,
  Act_MoveDilu = 35,
  Act_AbsorbDilu = 36,
  Act_DischargeDilu = 37,
  Act_UpdateFpga = 38,
  Act_sleepCtl = 39,
  Act_washLong = 40,
  Act_washShort = 41,
  Act_SetWTemp = 42,
  Act_SetRTemp = 43,
  Act_Timer = 44,
  Act_MoveAbs = 45,
  Act_MoveW = 46,
  Act_MoveInner = 47,
  Act_MoveOuter = 48,
  Act_OneAD = 49,
  Act_SetGain = 50,
  Act_GetShelf = 51,
  Act_FreeShelf = 52,
  Act_MoveDisg = 53,
  Act_GetIn = 54,
  Act_FreeShelfIn = 55,
  Act_StateSwitch = 56,
  Act_TempControl = 57,
  Act_GwPushIn = 100,
  Act_GwShelfScan = 101,
  Act_GwScheduGet = 104,
  Act_GwScheduPut = 105,
  Act_GwTransNorm = 106,
  Act_GwTransEmer = 107,
  Act_GwFreeGet = 108,
  Act_GwFreePop = 109,
  Act_GwRecycle = 111,
  Act_GwFreeRecy = 112,
  Act_GwPushOut = 113,
  Act_GwChangNorm = 114,
  Act_GwChangEmer = 115,
  Act_GwChangRecy = 116,
  Act_TPMoveL = 120,
  Act_TPMoveF = 121,
  Act_TPMoveR = 122,
  Act_VGMoveL = 123,
  Act_VGMoveF = 124,
  Act_VGMoveR = 125
};
bool ActType_IsValid(int value);
const ActType ActType_MIN = Act_Reset;
const ActType ActType_MAX = Act_VGMoveR;
const int ActType_ARRAYSIZE = ActType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActType_descriptor();
inline const ::std::string& ActType_Name(ActType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActType_descriptor(), value);
}
inline bool ActType_Parse(
    const ::std::string& name, ActType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActType>(
    ActType_descriptor(), name, value);
}
enum ServerPid {
  SPid_SocketMonitor = 401,
  SPid_Oammng = 509,
  SPid_BcScan = 510,
  SPid_Maintain = 520,
  SPid_CheckLightCup = 530,
  SPid_DarkCurrent = 540,
  SPid_Alarm = 550,
  Spid_UpdateDwn = 560,
  SPid_Showave = 570,
  SPid_Smooth = 580,
  SPid_ShowAD = 590,
  SPid_Task = 701,
  SPid_MarginScan = 703,
  SPid_AirOut = 704,
  SPid_IntensifyWash = 705,
  SPid_Reset = 706,
  SPid_DwnCmd = 707,
  SPid_PreciseAdd = 708,
  SPid_TmpSwitch = 709,
  SPid_SmpNdl = 901,
  SPid_SmpNdlb = 902,
  SPid_ReactDsk = 903,
  SPid_AutoWash = 904,
  SPid_SMix = 905,
  SPid_R2Mix = 906,
  SPid_R1 = 907,
  SPid_R1Dsk = 908,
  SPid_R1b = 909,
  SPid_R2 = 910,
  SPid_R2Dsk = 911,
  SPid_R2b = 912,
  SPid_RTmpCtrl = 913,
  SPid_WTmpCtrl = 914,
  SPid_CoolReag = 915,
  SPid_ADOuter = 916,
  SPid_ADInner = 917,
  SPid_SmpDsk = 919,
  SPid_SmpEmer = 920,
  SPid_Press = 921,
  SPid_TmpCtrl = 922,
  SPid_AutoPowerOn = 925,
  SPid_Light = 926,
  SPid_31 = 931,
  SPid_32 = 932,
  SPid_33 = 933,
  SPid_34 = 934,
  SPid_35 = 935,
  SPid_36 = 936,
  SPid_37 = 937,
  SPid_38 = 938,
  SPid_39 = 939,
  SPid_40 = 940,
  SPid_AutoLoad = 950,
  SPid_Transport = 951,
  SPid_VerticalGripper = 952,
  SPid_L1 = 953,
  SPid_L2 = 954,
  SPid_TaskResult = 1001
};
bool ServerPid_IsValid(int value);
const ServerPid ServerPid_MIN = SPid_SocketMonitor;
const ServerPid ServerPid_MAX = SPid_TaskResult;
const int ServerPid_ARRAYSIZE = ServerPid_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerPid_descriptor();
inline const ::std::string& ServerPid_Name(ServerPid value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerPid_descriptor(), value);
}
inline bool ServerPid_Parse(
    const ::std::string& name, ServerPid* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerPid>(
    ServerPid_descriptor(), name, value);
}
enum CilentPid {
  CPid_SocketMonitor = 402,
  GPid_GwayMonitor = 403,
  CPid_Reagent = 504,
  CPid_ReactDiskMonitor = 508,
  CPid_Maintain = 510,
  CPid_Alarm = 513,
  CPid_Sound = 514,
  CPid_OffSet = 520,
  CPid_Consum = 530,
  CPid_Relation = 540,
  CPid_SmpTask = 901,
  CPid_Calibrate = 903,
  CPid_SendTask = 1001
};
bool CilentPid_IsValid(int value);
const CilentPid CilentPid_MIN = CPid_SocketMonitor;
const CilentPid CilentPid_MAX = CPid_SendTask;
const int CilentPid_ARRAYSIZE = CilentPid_MAX + 1;

const ::google::protobuf::EnumDescriptor* CilentPid_descriptor();
inline const ::std::string& CilentPid_Name(CilentPid value) {
  return ::google::protobuf::internal::NameOfEnum(
    CilentPid_descriptor(), value);
}
inline bool CilentPid_Parse(
    const ::std::string& name, CilentPid* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CilentPid>(
    CilentPid_descriptor(), name, value);
}
enum CupState {
  CUP_STATE_FREE = 0,
  CUP_STATE_WASH = 1,
  CUP_STATE_R1 = 2,
  CUP_STATE_SAMPLE = 3,
  CUP_STATE_R2 = 4,
  CUP_STATE_R3 = 5,
  CUP_STATE_R4 = 6,
  CUP_STATE_REACTION = 7,
  CUP_STATE_DIRTY = 8,
  CUP_STATE_BUTT = 9
};
bool CupState_IsValid(int value);
const CupState CupState_MIN = CUP_STATE_FREE;
const CupState CupState_MAX = CUP_STATE_BUTT;
const int CupState_ARRAYSIZE = CupState_MAX + 1;

const ::google::protobuf::EnumDescriptor* CupState_descriptor();
inline const ::std::string& CupState_Name(CupState value) {
  return ::google::protobuf::internal::NameOfEnum(
    CupState_descriptor(), value);
}
inline bool CupState_Parse(
    const ::std::string& name, CupState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CupState>(
    CupState_descriptor(), name, value);
}
enum DevType {
  SampleNdl = 0,
  R1Ndl = 1,
  R2Ndl = 2
};
bool DevType_IsValid(int value);
const DevType DevType_MIN = SampleNdl;
const DevType DevType_MAX = R2Ndl;
const int DevType_ARRAYSIZE = DevType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DevType_descriptor();
inline const ::std::string& DevType_Name(DevType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DevType_descriptor(), value);
}
inline bool DevType_Parse(
    const ::std::string& name, DevType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DevType>(
    DevType_descriptor(), name, value);
}
enum BottleType {
  BT_standard = 2,
  BT_micro = 1,
  BT_middle = 3
};
bool BottleType_IsValid(int value);
const BottleType BottleType_MIN = BT_micro;
const BottleType BottleType_MAX = BT_middle;
const int BottleType_ARRAYSIZE = BottleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BottleType_descriptor();
inline const ::std::string& BottleType_Name(BottleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BottleType_descriptor(), value);
}
inline bool BottleType_Parse(
    const ::std::string& name, BottleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BottleType>(
    BottleType_descriptor(), name, value);
}
enum ReagDiskType {
  ReagDisk_Default = 1,
  ReagDisk_AutoLoad = 2
};
bool ReagDiskType_IsValid(int value);
const ReagDiskType ReagDiskType_MIN = ReagDisk_Default;
const ReagDiskType ReagDiskType_MAX = ReagDisk_AutoLoad;
const int ReagDiskType_ARRAYSIZE = ReagDiskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReagDiskType_descriptor();
inline const ::std::string& ReagDiskType_Name(ReagDiskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReagDiskType_descriptor(), value);
}
inline bool ReagDiskType_Parse(
    const ::std::string& name, ReagDiskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReagDiskType>(
    ReagDiskType_descriptor(), name, value);
}
enum SmpDskPos {
  SmpPosAbsrb1 = 0,
  SmpPosAbsrb2 = 1,
  SmpPosAbsrb3 = 2,
  SmpPosAbsrb4 = 3,
  SmpPosAbsrb5 = 4,
  SmpPosWash = 5,
  SmpPosRailAbsrb = 6,
  SmpPosDilute = 7,
  SmpPosDischNml = 8,
  SmpPosDischISE = 9
};
bool SmpDskPos_IsValid(int value);
const SmpDskPos SmpDskPos_MIN = SmpPosAbsrb1;
const SmpDskPos SmpDskPos_MAX = SmpPosDischISE;
const int SmpDskPos_ARRAYSIZE = SmpDskPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* SmpDskPos_descriptor();
inline const ::std::string& SmpDskPos_Name(SmpDskPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    SmpDskPos_descriptor(), value);
}
inline bool SmpDskPos_Parse(
    const ::std::string& name, SmpDskPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SmpDskPos>(
    SmpDskPos_descriptor(), name, value);
}
enum RegDskPos {
  RegPossWash = 0,
  RegPossAbsrb = 1,
  RegPossDischarg = 2
};
bool RegDskPos_IsValid(int value);
const RegDskPos RegDskPos_MIN = RegPossWash;
const RegDskPos RegDskPos_MAX = RegPossDischarg;
const int RegDskPos_ARRAYSIZE = RegDskPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegDskPos_descriptor();
inline const ::std::string& RegDskPos_Name(RegDskPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegDskPos_descriptor(), value);
}
inline bool RegDskPos_Parse(
    const ::std::string& name, RegDskPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegDskPos>(
    RegDskPos_descriptor(), name, value);
}
enum MixNdlDskPos {
  MixPossWash = 0,
  MixPoss33 = 1,
  MixPoss38 = 2,
  MixPoss67 = 3
};
bool MixNdlDskPos_IsValid(int value);
const MixNdlDskPos MixNdlDskPos_MIN = MixPossWash;
const MixNdlDskPos MixNdlDskPos_MAX = MixPoss67;
const int MixNdlDskPos_ARRAYSIZE = MixNdlDskPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* MixNdlDskPos_descriptor();
inline const ::std::string& MixNdlDskPos_Name(MixNdlDskPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    MixNdlDskPos_descriptor(), value);
}
inline bool MixNdlDskPos_Parse(
    const ::std::string& name, MixNdlDskPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MixNdlDskPos>(
    MixNdlDskPos_descriptor(), name, value);
}
enum TaskResult {
  TR_Success = 0,
  TR_SysFault = 1,
  TR_ReagErr = 2,
  TR_GetADErr = 3,
  TR_AddR1Err = 4,
  TR_AddR2Err = 5,
  TR_AddR3Err = 6,
  TR_AddR4Err = 7,
  TR_AddSmpErr = 8,
  TR_UserCancel = 9,
  TR_NetErr = 10,
  TR_DilOver = 11,
  TR_Skip = 12
};
bool TaskResult_IsValid(int value);
const TaskResult TaskResult_MIN = TR_Success;
const TaskResult TaskResult_MAX = TR_Skip;
const int TaskResult_ARRAYSIZE = TaskResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskResult_descriptor();
inline const ::std::string& TaskResult_Name(TaskResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskResult_descriptor(), value);
}
inline bool TaskResult_Parse(
    const ::std::string& name, TaskResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskResult>(
    TaskResult_descriptor(), name, value);
}
enum CollideNdl {
  collide_stop = 1,
  collide_cancel = 2,
  collide_null = 3
};
bool CollideNdl_IsValid(int value);
const CollideNdl CollideNdl_MIN = collide_stop;
const CollideNdl CollideNdl_MAX = collide_null;
const int CollideNdl_ARRAYSIZE = CollideNdl_MAX + 1;

const ::google::protobuf::EnumDescriptor* CollideNdl_descriptor();
inline const ::std::string& CollideNdl_Name(CollideNdl value) {
  return ::google::protobuf::internal::NameOfEnum(
    CollideNdl_descriptor(), value);
}
inline bool CollideNdl_Parse(
    const ::std::string& name, CollideNdl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollideNdl>(
    CollideNdl_descriptor(), name, value);
}
enum UpdateResult {
  UR_success = 0,
  UR_failed = 1,
  UR_ing = 2,
  UR_stop = 3
};
bool UpdateResult_IsValid(int value);
const UpdateResult UpdateResult_MIN = UR_success;
const UpdateResult UpdateResult_MAX = UR_stop;
const int UpdateResult_ARRAYSIZE = UpdateResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpdateResult_descriptor();
inline const ::std::string& UpdateResult_Name(UpdateResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpdateResult_descriptor(), value);
}
inline bool UpdateResult_Parse(
    const ::std::string& name, UpdateResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateResult>(
    UpdateResult_descriptor(), name, value);
}
enum LiquidDBG_Type {
  app_deion_pipe_flood_req = 1,
  app_smp_pipe_flood_req = 2,
  app_r1_pipe_flood_req = 3,
  app_r2_pipe_flood_req = 4,
  app_complete_drain_req = 5,
  app_add_smponly_req = 6,
  app_add_r1only_req = 7,
  app_add_r2only_req = 8,
  app_drain_smponly_req = 9,
  app_drain_r1only_req = 10,
  app_drain_r2only_req = 11,
  app_drain_add_smp_req = 12,
  app_drain_add_r1_req = 13,
  app_drain_add_r2_req = 14,
  app_auto_wash_test_2_req = 15,
  app_auto_wash_test_3_req = 16,
  app_auto_wash_test_4_req = 17,
  app_auto_wash_test_6_req = 18,
  app_auto_wash_test_71_req = 19,
  app_auto_wash_test_72_req = 20,
  app_auto_wash_close_allPV_req = 21,
  washDBG_WR = 22,
  washDBG_WW = 23,
  washDBG_OMVA = 24,
  washDBG_CMVA = 25,
  app_accuracyAddS = 26,
  app_accuracyAddR1 = 27,
  app_accuracyAddR2 = 28,
  app_accuracyRMix = 29,
  app_accuracySMix = 30,
  app_smpb_pipe_flood_req = 31,
  app_r1b_pipe_flood_req = 32,
  app_r2b_pipe_flood_req = 33,
  app_drain_add_req = 34,
  app_add_req = 35,
  app_drain_req = 36,
  app_accuracyAdd = 37
};
bool LiquidDBG_Type_IsValid(int value);
const LiquidDBG_Type LiquidDBG_Type_MIN = app_deion_pipe_flood_req;
const LiquidDBG_Type LiquidDBG_Type_MAX = app_accuracyAdd;
const int LiquidDBG_Type_ARRAYSIZE = LiquidDBG_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LiquidDBG_Type_descriptor();
inline const ::std::string& LiquidDBG_Type_Name(LiquidDBG_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LiquidDBG_Type_descriptor(), value);
}
inline bool LiquidDBG_Type_Parse(
    const ::std::string& name, LiquidDBG_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LiquidDBG_Type>(
    LiquidDBG_Type_descriptor(), name, value);
}
enum FLx_enum {
  FL01_low = 0,
  FL01_high = 1,
  FL05_low = 2,
  FL05_high = 3,
  FL06_low = 4,
  FL06_high = 5,
  FL10 = 6,
  FL11 = 7,
  FL12 = 8,
  FL13 = 9,
  FL14 = 10,
  FLise = 11,
  FLiseB = 12
};
bool FLx_enum_IsValid(int value);
const FLx_enum FLx_enum_MIN = FL01_low;
const FLx_enum FLx_enum_MAX = FLiseB;
const int FLx_enum_ARRAYSIZE = FLx_enum_MAX + 1;

const ::google::protobuf::EnumDescriptor* FLx_enum_descriptor();
inline const ::std::string& FLx_enum_Name(FLx_enum value) {
  return ::google::protobuf::internal::NameOfEnum(
    FLx_enum_descriptor(), value);
}
inline bool FLx_enum_Parse(
    const ::std::string& name, FLx_enum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FLx_enum>(
    FLx_enum_descriptor(), name, value);
}
enum FLx_state {
  FLX_ON = 0,
  FLX_OFF = 1,
  FLx_idll = 255
};
bool FLx_state_IsValid(int value);
const FLx_state FLx_state_MIN = FLX_ON;
const FLx_state FLx_state_MAX = FLx_idll;
const int FLx_state_ARRAYSIZE = FLx_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* FLx_state_descriptor();
inline const ::std::string& FLx_state_Name(FLx_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    FLx_state_descriptor(), value);
}
inline bool FLx_state_Parse(
    const ::std::string& name, FLx_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FLx_state>(
    FLx_state_descriptor(), name, value);
}
enum EN_DilutTaskType {
  EN_DilutNorm = 0,
  EN_DilutType = 1,
  EN_ReactionType = 2
};
bool EN_DilutTaskType_IsValid(int value);
const EN_DilutTaskType EN_DilutTaskType_MIN = EN_DilutNorm;
const EN_DilutTaskType EN_DilutTaskType_MAX = EN_ReactionType;
const int EN_DilutTaskType_ARRAYSIZE = EN_DilutTaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EN_DilutTaskType_descriptor();
inline const ::std::string& EN_DilutTaskType_Name(EN_DilutTaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EN_DilutTaskType_descriptor(), value);
}
inline bool EN_DilutTaskType_Parse(
    const ::std::string& name, EN_DilutTaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EN_DilutTaskType>(
    EN_DilutTaskType_descriptor(), name, value);
}
enum ConsumType {
  Csum_Wash = 998,
  Csum_Ligth = 999
};
bool ConsumType_IsValid(int value);
const ConsumType ConsumType_MIN = Csum_Wash;
const ConsumType ConsumType_MAX = Csum_Ligth;
const int ConsumType_ARRAYSIZE = ConsumType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConsumType_descriptor();
inline const ::std::string& ConsumType_Name(ConsumType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConsumType_descriptor(), value);
}
inline bool ConsumType_Parse(
    const ::std::string& name, ConsumType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConsumType>(
    ConsumType_descriptor(), name, value);
}
enum ReactCircle {
  Circle_All = 0,
  Circle_Outer = 1,
  Circle_Inner = 2
};
bool ReactCircle_IsValid(int value);
const ReactCircle ReactCircle_MIN = Circle_All;
const ReactCircle ReactCircle_MAX = Circle_Inner;
const int ReactCircle_ARRAYSIZE = ReactCircle_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReactCircle_descriptor();
inline const ::std::string& ReactCircle_Name(ReactCircle value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReactCircle_descriptor(), value);
}
inline bool ReactCircle_Parse(
    const ::std::string& name, ReactCircle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReactCircle>(
    ReactCircle_descriptor(), name, value);
}
enum ShelfCtrlType {
  Shelf_Req = 1,
  Shelf_Res = 2,
  Shelf_Free = 3
};
bool ShelfCtrlType_IsValid(int value);
const ShelfCtrlType ShelfCtrlType_MIN = Shelf_Req;
const ShelfCtrlType ShelfCtrlType_MAX = Shelf_Free;
const int ShelfCtrlType_ARRAYSIZE = ShelfCtrlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShelfCtrlType_descriptor();
inline const ::std::string& ShelfCtrlType_Name(ShelfCtrlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShelfCtrlType_descriptor(), value);
}
inline bool ShelfCtrlType_Parse(
    const ::std::string& name, ShelfCtrlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShelfCtrlType>(
    ShelfCtrlType_descriptor(), name, value);
}
enum MachUnit {
  Unit_Gway = 0,
  Unit_A1 = 1,
  Unit_A2 = 2,
  Unit_A3 = 3,
  Unit_A4 = 4,
  Unit_UI = 5
};
bool MachUnit_IsValid(int value);
const MachUnit MachUnit_MIN = Unit_Gway;
const MachUnit MachUnit_MAX = Unit_UI;
const int MachUnit_ARRAYSIZE = MachUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* MachUnit_descriptor();
inline const ::std::string& MachUnit_Name(MachUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    MachUnit_descriptor(), value);
}
inline bool MachUnit_Parse(
    const ::std::string& name, MachUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MachUnit>(
    MachUnit_descriptor(), name, value);
}
enum SmpNdlPos {
  SNdlPosDilute = 0,
  SNdlPosDischarg = 1,
  SNdlPosReset = 2,
  SNdlPosW1 = 3,
  SNdlPosW2 = 4,
  SNdlPosW3 = 5,
  SNdlPosEmer = 6,
  SNdlPosNorm = 7
};
bool SmpNdlPos_IsValid(int value);
const SmpNdlPos SmpNdlPos_MIN = SNdlPosDilute;
const SmpNdlPos SmpNdlPos_MAX = SNdlPosNorm;
const int SmpNdlPos_ARRAYSIZE = SmpNdlPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* SmpNdlPos_descriptor();
inline const ::std::string& SmpNdlPos_Name(SmpNdlPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    SmpNdlPos_descriptor(), value);
}
inline bool SmpNdlPos_Parse(
    const ::std::string& name, SmpNdlPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SmpNdlPos>(
    SmpNdlPos_descriptor(), name, value);
}
enum R1DskPos {
  R1DskPosouter1 = 1,
  R1DskPosouter2 = 7,
  R1DskPosInner1 = 10,
  R1DskPosInner2 = 4
};
bool R1DskPos_IsValid(int value);
const R1DskPos R1DskPos_MIN = R1DskPosouter1;
const R1DskPos R1DskPos_MAX = R1DskPosInner1;
const int R1DskPos_ARRAYSIZE = R1DskPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* R1DskPos_descriptor();
inline const ::std::string& R1DskPos_Name(R1DskPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    R1DskPos_descriptor(), value);
}
inline bool R1DskPos_Parse(
    const ::std::string& name, R1DskPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<R1DskPos>(
    R1DskPos_descriptor(), name, value);
}
enum R2DskPos {
  R2DskPosouter1 = 1,
  R2DskPosouter2 = 9,
  R2DskPosInner1 = 12,
  R2DskPosInner2 = 4
};
bool R2DskPos_IsValid(int value);
const R2DskPos R2DskPos_MIN = R2DskPosouter1;
const R2DskPos R2DskPos_MAX = R2DskPosInner1;
const int R2DskPos_ARRAYSIZE = R2DskPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* R2DskPos_descriptor();
inline const ::std::string& R2DskPos_Name(R2DskPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    R2DskPos_descriptor(), value);
}
inline bool R2DskPos_Parse(
    const ::std::string& name, R2DskPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<R2DskPos>(
    R2DskPos_descriptor(), name, value);
}
enum ReagNdlPos {
  RNdlPosDischarg = 1,
  RNdlPosReset = 2,
  RNdlPosW1 = 3,
  RNdlPosW2 = 4,
  RNdlPosW3 = 5,
  RNdlPosAbsorb1 = 6,
  RNdlPosAbsorb2 = 7
};
bool ReagNdlPos_IsValid(int value);
const ReagNdlPos ReagNdlPos_MIN = RNdlPosDischarg;
const ReagNdlPos ReagNdlPos_MAX = RNdlPosAbsorb2;
const int ReagNdlPos_ARRAYSIZE = ReagNdlPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReagNdlPos_descriptor();
inline const ::std::string& ReagNdlPos_Name(ReagNdlPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReagNdlPos_descriptor(), value);
}
inline bool ReagNdlPos_Parse(
    const ::std::string& name, ReagNdlPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReagNdlPos>(
    ReagNdlPos_descriptor(), name, value);
}
enum IntensifyWashType {
  IntensifyWashAcid = 1,
  IntensifyWashAlkali = 2,
  IntensifyWashAcidAlkali = 3
};
bool IntensifyWashType_IsValid(int value);
const IntensifyWashType IntensifyWashType_MIN = IntensifyWashAcid;
const IntensifyWashType IntensifyWashType_MAX = IntensifyWashAcidAlkali;
const int IntensifyWashType_ARRAYSIZE = IntensifyWashType_MAX + 1;

const ::google::protobuf::EnumDescriptor* IntensifyWashType_descriptor();
inline const ::std::string& IntensifyWashType_Name(IntensifyWashType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IntensifyWashType_descriptor(), value);
}
inline bool IntensifyWashType_Parse(
    const ::std::string& name, IntensifyWashType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IntensifyWashType>(
    IntensifyWashType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgType>() {
  return ::MsgType_descriptor();
}
template <> struct is_proto_enum< ::ActType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActType>() {
  return ::ActType_descriptor();
}
template <> struct is_proto_enum< ::ServerPid> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerPid>() {
  return ::ServerPid_descriptor();
}
template <> struct is_proto_enum< ::CilentPid> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CilentPid>() {
  return ::CilentPid_descriptor();
}
template <> struct is_proto_enum< ::CupState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CupState>() {
  return ::CupState_descriptor();
}
template <> struct is_proto_enum< ::DevType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DevType>() {
  return ::DevType_descriptor();
}
template <> struct is_proto_enum< ::BottleType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BottleType>() {
  return ::BottleType_descriptor();
}
template <> struct is_proto_enum< ::ReagDiskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ReagDiskType>() {
  return ::ReagDiskType_descriptor();
}
template <> struct is_proto_enum< ::SmpDskPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SmpDskPos>() {
  return ::SmpDskPos_descriptor();
}
template <> struct is_proto_enum< ::RegDskPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RegDskPos>() {
  return ::RegDskPos_descriptor();
}
template <> struct is_proto_enum< ::MixNdlDskPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MixNdlDskPos>() {
  return ::MixNdlDskPos_descriptor();
}
template <> struct is_proto_enum< ::TaskResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TaskResult>() {
  return ::TaskResult_descriptor();
}
template <> struct is_proto_enum< ::CollideNdl> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CollideNdl>() {
  return ::CollideNdl_descriptor();
}
template <> struct is_proto_enum< ::UpdateResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UpdateResult>() {
  return ::UpdateResult_descriptor();
}
template <> struct is_proto_enum< ::LiquidDBG_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LiquidDBG_Type>() {
  return ::LiquidDBG_Type_descriptor();
}
template <> struct is_proto_enum< ::FLx_enum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FLx_enum>() {
  return ::FLx_enum_descriptor();
}
template <> struct is_proto_enum< ::FLx_state> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FLx_state>() {
  return ::FLx_state_descriptor();
}
template <> struct is_proto_enum< ::EN_DilutTaskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EN_DilutTaskType>() {
  return ::EN_DilutTaskType_descriptor();
}
template <> struct is_proto_enum< ::ConsumType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ConsumType>() {
  return ::ConsumType_descriptor();
}
template <> struct is_proto_enum< ::ReactCircle> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ReactCircle>() {
  return ::ReactCircle_descriptor();
}
template <> struct is_proto_enum< ::ShelfCtrlType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShelfCtrlType>() {
  return ::ShelfCtrlType_descriptor();
}
template <> struct is_proto_enum< ::MachUnit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MachUnit>() {
  return ::MachUnit_descriptor();
}
template <> struct is_proto_enum< ::SmpNdlPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SmpNdlPos>() {
  return ::SmpNdlPos_descriptor();
}
template <> struct is_proto_enum< ::R1DskPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::R1DskPos>() {
  return ::R1DskPos_descriptor();
}
template <> struct is_proto_enum< ::R2DskPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::R2DskPos>() {
  return ::R2DskPos_descriptor();
}
template <> struct is_proto_enum< ::ReagNdlPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ReagNdlPos>() {
  return ::ReagNdlPos_descriptor();
}
template <> struct is_proto_enum< ::IntensifyWashType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IntensifyWashType>() {
  return ::IntensifyWashType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_typedefine_2eproto__INCLUDED
