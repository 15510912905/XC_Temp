// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: upmsgstruct.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "upmsgstruct.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* STKeyValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STKeyValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* STAdPoints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STAdPoints_reflection_ = NULL;
const ::google::protobuf::Descriptor* STCupPos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STCupPos_reflection_ = NULL;
const ::google::protobuf::Descriptor* STMarginScan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STMarginScan_reflection_ = NULL;
const ::google::protobuf::Descriptor* STLiquidInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STLiquidInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* STRctCupStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STRctCupStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* STBarcodeScan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STBarcodeScan_reflection_ = NULL;
const ::google::protobuf::Descriptor* STReagInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STReagInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* STThreshold_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STThreshold_reflection_ = NULL;
const ::google::protobuf::Descriptor* STCupADValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STCupADValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* STOffsetPara_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STOffsetPara_reflection_ = NULL;
const ::google::protobuf::Descriptor* STDarkCurrentAD_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STDarkCurrentAD_reflection_ = NULL;
const ::google::protobuf::Descriptor* STSubVers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STSubVers_reflection_ = NULL;
const ::google::protobuf::Descriptor* STAlarmInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STAlarmInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* STTestVal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STTestVal_reflection_ = NULL;
const ::google::protobuf::Descriptor* SmosData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SmosData_reflection_ = NULL;
const ::google::protobuf::Descriptor* STAbSorbSmos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STAbSorbSmos_reflection_ = NULL;
const ::google::protobuf::Descriptor* STCupID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STCupID_reflection_ = NULL;
const ::google::protobuf::Descriptor* STSmpBacode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  STSmpBacode_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_upmsgstruct_2eproto() {
  protobuf_AddDesc_upmsgstruct_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "upmsgstruct.proto");
  GOOGLE_CHECK(file != NULL);
  STKeyValue_descriptor_ = file->message_type(0);
  static const int STKeyValue_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STKeyValue, uikey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STKeyValue, uival_),
  };
  STKeyValue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STKeyValue_descriptor_,
      STKeyValue::default_instance_,
      STKeyValue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STKeyValue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STKeyValue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STKeyValue));
  STAdPoints_descriptor_ = file->message_type(1);
  static const int STAdPoints_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAdPoints, uiadpoints_),
  };
  STAdPoints_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STAdPoints_descriptor_,
      STAdPoints::default_instance_,
      STAdPoints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAdPoints, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAdPoints, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STAdPoints));
  STCupPos_descriptor_ = file->message_type(2);
  static const int STCupPos_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupPos, uidskid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupPos, uicupid_),
  };
  STCupPos_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STCupPos_descriptor_,
      STCupPos::default_instance_,
      STCupPos_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupPos, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupPos, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STCupPos));
  STMarginScan_descriptor_ = file->message_type(3);
  static const int STMarginScan_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STMarginScan, stcuppos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STMarginScan, uimargindepth_),
  };
  STMarginScan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STMarginScan_descriptor_,
      STMarginScan::default_instance_,
      STMarginScan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STMarginScan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STMarginScan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STMarginScan));
  STLiquidInfo_descriptor_ = file->message_type(4);
  static const int STLiquidInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STLiquidInfo, stcuppos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STLiquidInfo, uiaddvol_),
  };
  STLiquidInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STLiquidInfo_descriptor_,
      STLiquidInfo::default_instance_,
      STLiquidInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STLiquidInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STLiquidInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STLiquidInfo));
  STRctCupStatus_descriptor_ = file->message_type(5);
  static const int STRctCupStatus_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, uirctcuppos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, encupstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, uircttimes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, uitaskid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, stsmppos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, uidiluttype_),
  };
  STRctCupStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STRctCupStatus_descriptor_,
      STRctCupStatus::default_instance_,
      STRctCupStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STRctCupStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STRctCupStatus));
  STBarcodeScan_descriptor_ = file->message_type(6);
  static const int STBarcodeScan_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STBarcodeScan, stcuppos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STBarcodeScan, strbarcode_),
  };
  STBarcodeScan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STBarcodeScan_descriptor_,
      STBarcodeScan::default_instance_,
      STBarcodeScan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STBarcodeScan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STBarcodeScan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STBarcodeScan));
  STReagInfo_descriptor_ = file->message_type(7);
  static const int STReagInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STReagInfo, stcuppos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STReagInfo, strreagname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STReagInfo, enbtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STReagInfo, uimargindepth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STReagInfo, uiretype_),
  };
  STReagInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STReagInfo_descriptor_,
      STReagInfo::default_instance_,
      STReagInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STReagInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STReagInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STReagInfo));
  STThreshold_descriptor_ = file->message_type(8);
  static const int STThreshold_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STThreshold, enbtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STThreshold, uithreshold_),
  };
  STThreshold_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STThreshold_descriptor_,
      STThreshold::default_instance_,
      STThreshold_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STThreshold, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STThreshold, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STThreshold));
  STCupADValue_descriptor_ = file->message_type(9);
  static const int STCupADValue_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupADValue, uicupid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupADValue, uiadpoints_),
  };
  STCupADValue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STCupADValue_descriptor_,
      STCupADValue::default_instance_,
      STCupADValue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupADValue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupADValue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STCupADValue));
  STOffsetPara_descriptor_ = file->message_type(10);
  static const int STOffsetPara_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STOffsetPara, uitype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STOffsetPara, uipos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STOffsetPara, uidir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STOffsetPara, uistep_),
  };
  STOffsetPara_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STOffsetPara_descriptor_,
      STOffsetPara::default_instance_,
      STOffsetPara_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STOffsetPara, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STOffsetPara, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STOffsetPara));
  STDarkCurrentAD_descriptor_ = file->message_type(11);
  static const int STDarkCurrentAD_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STDarkCurrentAD, stadinfo_),
  };
  STDarkCurrentAD_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STDarkCurrentAD_descriptor_,
      STDarkCurrentAD::default_instance_,
      STDarkCurrentAD_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STDarkCurrentAD, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STDarkCurrentAD, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STDarkCurrentAD));
  STSubVers_descriptor_ = file->message_type(12);
  static const int STSubVers_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSubVers, ulsubsysid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSubVers, strtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSubVers, strversions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSubVers, fpgaver_),
  };
  STSubVers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STSubVers_descriptor_,
      STSubVers::default_instance_,
      STSubVers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSubVers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSubVers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STSubVers));
  STAlarmInfo_descriptor_ = file->message_type(13);
  static const int STAlarmInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAlarmInfo, ulalarmid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAlarmInfo, ulparas_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAlarmInfo, strtime_),
  };
  STAlarmInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STAlarmInfo_descriptor_,
      STAlarmInfo::default_instance_,
      STAlarmInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAlarmInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAlarmInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STAlarmInfo));
  STTestVal_descriptor_ = file->message_type(14);
  static const int STTestVal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STTestVal, uicup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STTestVal, uival_),
  };
  STTestVal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STTestVal_descriptor_,
      STTestVal::default_instance_,
      STTestVal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STTestVal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STTestVal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STTestVal));
  SmosData_descriptor_ = file->message_type(15);
  static const int SmosData_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, prj_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, startp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, endp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, order_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, startbadp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, endbadp_),
  };
  SmosData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SmosData_descriptor_,
      SmosData::default_instance_,
      SmosData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmosData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SmosData));
  STAbSorbSmos_descriptor_ = file->message_type(16);
  static const int STAbSorbSmos_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAbSorbSmos, data_),
  };
  STAbSorbSmos_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STAbSorbSmos_descriptor_,
      STAbSorbSmos::default_instance_,
      STAbSorbSmos_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAbSorbSmos, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STAbSorbSmos, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STAbSorbSmos));
  STCupID_descriptor_ = file->message_type(17);
  static const int STCupID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupID, id_),
  };
  STCupID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STCupID_descriptor_,
      STCupID::default_instance_,
      STCupID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STCupID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STCupID));
  STSmpBacode_descriptor_ = file->message_type(18);
  static const int STSmpBacode_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSmpBacode, cupno_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSmpBacode, barcode_),
  };
  STSmpBacode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      STSmpBacode_descriptor_,
      STSmpBacode::default_instance_,
      STSmpBacode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSmpBacode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(STSmpBacode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(STSmpBacode));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_upmsgstruct_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STKeyValue_descriptor_, &STKeyValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STAdPoints_descriptor_, &STAdPoints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STCupPos_descriptor_, &STCupPos::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STMarginScan_descriptor_, &STMarginScan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STLiquidInfo_descriptor_, &STLiquidInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STRctCupStatus_descriptor_, &STRctCupStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STBarcodeScan_descriptor_, &STBarcodeScan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STReagInfo_descriptor_, &STReagInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STThreshold_descriptor_, &STThreshold::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STCupADValue_descriptor_, &STCupADValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STOffsetPara_descriptor_, &STOffsetPara::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STDarkCurrentAD_descriptor_, &STDarkCurrentAD::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STSubVers_descriptor_, &STSubVers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STAlarmInfo_descriptor_, &STAlarmInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STTestVal_descriptor_, &STTestVal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SmosData_descriptor_, &SmosData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STAbSorbSmos_descriptor_, &STAbSorbSmos::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STCupID_descriptor_, &STCupID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    STSmpBacode_descriptor_, &STSmpBacode::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_upmsgstruct_2eproto() {
  delete STKeyValue::default_instance_;
  delete STKeyValue_reflection_;
  delete STAdPoints::default_instance_;
  delete STAdPoints_reflection_;
  delete STCupPos::default_instance_;
  delete STCupPos_reflection_;
  delete STMarginScan::default_instance_;
  delete STMarginScan_reflection_;
  delete STLiquidInfo::default_instance_;
  delete STLiquidInfo_reflection_;
  delete STRctCupStatus::default_instance_;
  delete STRctCupStatus_reflection_;
  delete STBarcodeScan::default_instance_;
  delete STBarcodeScan_reflection_;
  delete STReagInfo::default_instance_;
  delete STReagInfo_reflection_;
  delete STThreshold::default_instance_;
  delete STThreshold_reflection_;
  delete STCupADValue::default_instance_;
  delete STCupADValue_reflection_;
  delete STOffsetPara::default_instance_;
  delete STOffsetPara_reflection_;
  delete STDarkCurrentAD::default_instance_;
  delete STDarkCurrentAD_reflection_;
  delete STSubVers::default_instance_;
  delete STSubVers_reflection_;
  delete STAlarmInfo::default_instance_;
  delete STAlarmInfo_reflection_;
  delete STTestVal::default_instance_;
  delete STTestVal_reflection_;
  delete SmosData::default_instance_;
  delete SmosData_reflection_;
  delete STAbSorbSmos::default_instance_;
  delete STAbSorbSmos_reflection_;
  delete STCupID::default_instance_;
  delete STCupID_reflection_;
  delete STSmpBacode::default_instance_;
  delete STSmpBacode_reflection_;
}

void protobuf_AddDesc_upmsgstruct_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_typedefine_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021upmsgstruct.proto\032\020typedefine.proto\"*\n"
    "\nSTKeyValue\022\r\n\005uiKey\030\001 \001(\r\022\r\n\005uiVal\030\002 \001("
    "\r\" \n\nSTAdPoints\022\022\n\nuiADPoints\030\001 \003(\r\",\n\010S"
    "TCupPos\022\017\n\007uiDskId\030\001 \001(\r\022\017\n\007uiCupId\030\002 \001("
    "\r\"B\n\014STMarginScan\022\033\n\010stCupPos\030\001 \001(\0132\t.ST"
    "CupPos\022\025\n\ruiMarginDepth\030\002 \001(\r\"=\n\014STLiqui"
    "dInfo\022\033\n\010stCupPos\030\001 \001(\0132\t.STCupPos\022\020\n\010ui"
    "AddVol\030\002 \001(\r\"\254\001\n\016STRctCupStatus\022\023\n\013uiRct"
    "CupPos\030\001 \001(\r\022-\n\nenCupState\030\002 \001(\0162\t.CupSt"
    "ate:\016CUP_STATE_FREE\022\022\n\nuiRctTimes\030\003 \001(\r\022"
    "\020\n\010uiTaskId\030\004 \001(\r\022\033\n\010stSmpPos\030\005 \001(\0132\t.ST"
    "CupPos\022\023\n\013uiDilutType\030\006 \001(\r\"@\n\rSTBarcode"
    "Scan\022\033\n\010stCupPos\030\001 \001(\0132\t.STCupPos\022\022\n\nstr"
    "Barcode\030\002 \001(\t\"\205\001\n\nSTReagInfo\022\033\n\010stCupPos"
    "\030\001 \001(\0132\t.STCupPos\022\023\n\013strReagName\030\002 \001(\014\022\034"
    "\n\007enBType\030\003 \001(\0162\013.BottleType\022\025\n\ruiMargin"
    "Depth\030\004 \001(\r\022\020\n\010uiReType\030\005 \001(\r\"@\n\013STThres"
    "hold\022\034\n\007enBType\030\001 \001(\0162\013.BottleType\022\023\n\013ui"
    "Threshold\030\002 \001(\r\"3\n\014STCupADValue\022\017\n\007uiCup"
    "Id\030\001 \001(\r\022\022\n\nuiADPoints\030\002 \003(\r\"L\n\014STOffset"
    "Para\022\016\n\006uiType\030\001 \001(\r\022\r\n\005uiPos\030\002 \001(\r\022\r\n\005u"
    "iDir\030\003 \001(\r\022\016\n\006uiStep\030\004 \001(\r\"0\n\017STDarkCurr"
    "entAD\022\035\n\010stAdInfo\030\001 \003(\0132\013.STKeyValue\"V\n\t"
    "STSubVers\022\022\n\nulSubsysId\030\001 \001(\r\022\017\n\007strTime"
    "\030\002 \001(\t\022\023\n\013strVersions\030\003 \001(\t\022\017\n\007fpgaVer\030\004"
    " \001(\r\"B\n\013STAlarmInfo\022\021\n\tulAlarmId\030\001 \001(\r\022\017"
    "\n\007ulParas\030\002 \003(\r\022\017\n\007strTime\030\003 \001(\t\")\n\tSTTe"
    "stVal\022\r\n\005uiCup\030\001 \001(\r\022\r\n\005uiVal\030\002 \003(\r\"h\n\010S"
    "mosData\022\013\n\003prj\030\001 \001(\t\022\016\n\006startP\030\002 \001(\r\022\014\n\004"
    "endP\030\003 \001(\r\022\r\n\005order\030\004 \001(\r\022\021\n\tstartBadP\030\005"
    " \001(\r\022\017\n\007endBadP\030\006 \001(\r\"\'\n\014STAbSorbSmos\022\027\n"
    "\004data\030\001 \003(\0132\t.SmosData\"\025\n\007STCupID\022\n\n\002id\030"
    "\001 \003(\r\"-\n\013STSmpBacode\022\r\n\005cupno\030\001 \001(\r\022\017\n\007b"
    "arcode\030\002 \001(\t", 1332);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "upmsgstruct.proto", &protobuf_RegisterTypes);
  STKeyValue::default_instance_ = new STKeyValue();
  STAdPoints::default_instance_ = new STAdPoints();
  STCupPos::default_instance_ = new STCupPos();
  STMarginScan::default_instance_ = new STMarginScan();
  STLiquidInfo::default_instance_ = new STLiquidInfo();
  STRctCupStatus::default_instance_ = new STRctCupStatus();
  STBarcodeScan::default_instance_ = new STBarcodeScan();
  STReagInfo::default_instance_ = new STReagInfo();
  STThreshold::default_instance_ = new STThreshold();
  STCupADValue::default_instance_ = new STCupADValue();
  STOffsetPara::default_instance_ = new STOffsetPara();
  STDarkCurrentAD::default_instance_ = new STDarkCurrentAD();
  STSubVers::default_instance_ = new STSubVers();
  STAlarmInfo::default_instance_ = new STAlarmInfo();
  STTestVal::default_instance_ = new STTestVal();
  SmosData::default_instance_ = new SmosData();
  STAbSorbSmos::default_instance_ = new STAbSorbSmos();
  STCupID::default_instance_ = new STCupID();
  STSmpBacode::default_instance_ = new STSmpBacode();
  STKeyValue::default_instance_->InitAsDefaultInstance();
  STAdPoints::default_instance_->InitAsDefaultInstance();
  STCupPos::default_instance_->InitAsDefaultInstance();
  STMarginScan::default_instance_->InitAsDefaultInstance();
  STLiquidInfo::default_instance_->InitAsDefaultInstance();
  STRctCupStatus::default_instance_->InitAsDefaultInstance();
  STBarcodeScan::default_instance_->InitAsDefaultInstance();
  STReagInfo::default_instance_->InitAsDefaultInstance();
  STThreshold::default_instance_->InitAsDefaultInstance();
  STCupADValue::default_instance_->InitAsDefaultInstance();
  STOffsetPara::default_instance_->InitAsDefaultInstance();
  STDarkCurrentAD::default_instance_->InitAsDefaultInstance();
  STSubVers::default_instance_->InitAsDefaultInstance();
  STAlarmInfo::default_instance_->InitAsDefaultInstance();
  STTestVal::default_instance_->InitAsDefaultInstance();
  SmosData::default_instance_->InitAsDefaultInstance();
  STAbSorbSmos::default_instance_->InitAsDefaultInstance();
  STCupID::default_instance_->InitAsDefaultInstance();
  STSmpBacode::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_upmsgstruct_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_upmsgstruct_2eproto {
  StaticDescriptorInitializer_upmsgstruct_2eproto() {
    protobuf_AddDesc_upmsgstruct_2eproto();
  }
} static_descriptor_initializer_upmsgstruct_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int STKeyValue::kUiKeyFieldNumber;
const int STKeyValue::kUiValFieldNumber;
#endif  // !_MSC_VER

STKeyValue::STKeyValue()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STKeyValue)
}

void STKeyValue::InitAsDefaultInstance() {
}

STKeyValue::STKeyValue(const STKeyValue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STKeyValue)
}

void STKeyValue::SharedCtor() {
  _cached_size_ = 0;
  uikey_ = 0u;
  uival_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STKeyValue::~STKeyValue() {
  // @@protoc_insertion_point(destructor:STKeyValue)
  SharedDtor();
}

void STKeyValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STKeyValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STKeyValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STKeyValue_descriptor_;
}

const STKeyValue& STKeyValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STKeyValue* STKeyValue::default_instance_ = NULL;

STKeyValue* STKeyValue::New() const {
  return new STKeyValue;
}

void STKeyValue::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<STKeyValue*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uikey_, uival_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STKeyValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STKeyValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 uiKey = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uikey_)));
          set_has_uikey();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiVal;
        break;
      }

      // optional uint32 uiVal = 2;
      case 2: {
        if (tag == 16) {
         parse_uiVal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uival_)));
          set_has_uival();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STKeyValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STKeyValue)
  return false;
#undef DO_
}

void STKeyValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STKeyValue)
  // optional uint32 uiKey = 1;
  if (has_uikey()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uikey(), output);
  }

  // optional uint32 uiVal = 2;
  if (has_uival()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uival(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STKeyValue)
}

::google::protobuf::uint8* STKeyValue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STKeyValue)
  // optional uint32 uiKey = 1;
  if (has_uikey()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uikey(), target);
  }

  // optional uint32 uiVal = 2;
  if (has_uival()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->uival(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STKeyValue)
  return target;
}

int STKeyValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 uiKey = 1;
    if (has_uikey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uikey());
    }

    // optional uint32 uiVal = 2;
    if (has_uival()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uival());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STKeyValue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STKeyValue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STKeyValue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STKeyValue::MergeFrom(const STKeyValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uikey()) {
      set_uikey(from.uikey());
    }
    if (from.has_uival()) {
      set_uival(from.uival());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STKeyValue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STKeyValue::CopyFrom(const STKeyValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STKeyValue::IsInitialized() const {

  return true;
}

void STKeyValue::Swap(STKeyValue* other) {
  if (other != this) {
    std::swap(uikey_, other->uikey_);
    std::swap(uival_, other->uival_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STKeyValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STKeyValue_descriptor_;
  metadata.reflection = STKeyValue_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STAdPoints::kUiADPointsFieldNumber;
#endif  // !_MSC_VER

STAdPoints::STAdPoints()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STAdPoints)
}

void STAdPoints::InitAsDefaultInstance() {
}

STAdPoints::STAdPoints(const STAdPoints& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STAdPoints)
}

void STAdPoints::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STAdPoints::~STAdPoints() {
  // @@protoc_insertion_point(destructor:STAdPoints)
  SharedDtor();
}

void STAdPoints::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STAdPoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STAdPoints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STAdPoints_descriptor_;
}

const STAdPoints& STAdPoints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STAdPoints* STAdPoints::default_instance_ = NULL;

STAdPoints* STAdPoints::New() const {
  return new STAdPoints;
}

void STAdPoints::Clear() {
  uiadpoints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STAdPoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STAdPoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 uiADPoints = 1;
      case 1: {
        if (tag == 8) {
         parse_uiADPoints:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_uiadpoints())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_uiadpoints())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_uiADPoints;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STAdPoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STAdPoints)
  return false;
#undef DO_
}

void STAdPoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STAdPoints)
  // repeated uint32 uiADPoints = 1;
  for (int i = 0; i < this->uiadpoints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->uiadpoints(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STAdPoints)
}

::google::protobuf::uint8* STAdPoints::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STAdPoints)
  // repeated uint32 uiADPoints = 1;
  for (int i = 0; i < this->uiadpoints_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->uiadpoints(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STAdPoints)
  return target;
}

int STAdPoints::ByteSize() const {
  int total_size = 0;

  // repeated uint32 uiADPoints = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->uiadpoints_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->uiadpoints(i));
    }
    total_size += 1 * this->uiadpoints_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STAdPoints::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STAdPoints* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STAdPoints*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STAdPoints::MergeFrom(const STAdPoints& from) {
  GOOGLE_CHECK_NE(&from, this);
  uiadpoints_.MergeFrom(from.uiadpoints_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STAdPoints::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STAdPoints::CopyFrom(const STAdPoints& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STAdPoints::IsInitialized() const {

  return true;
}

void STAdPoints::Swap(STAdPoints* other) {
  if (other != this) {
    uiadpoints_.Swap(&other->uiadpoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STAdPoints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STAdPoints_descriptor_;
  metadata.reflection = STAdPoints_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STCupPos::kUiDskIdFieldNumber;
const int STCupPos::kUiCupIdFieldNumber;
#endif  // !_MSC_VER

STCupPos::STCupPos()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STCupPos)
}

void STCupPos::InitAsDefaultInstance() {
}

STCupPos::STCupPos(const STCupPos& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STCupPos)
}

void STCupPos::SharedCtor() {
  _cached_size_ = 0;
  uidskid_ = 0u;
  uicupid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STCupPos::~STCupPos() {
  // @@protoc_insertion_point(destructor:STCupPos)
  SharedDtor();
}

void STCupPos::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STCupPos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STCupPos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STCupPos_descriptor_;
}

const STCupPos& STCupPos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STCupPos* STCupPos::default_instance_ = NULL;

STCupPos* STCupPos::New() const {
  return new STCupPos;
}

void STCupPos::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<STCupPos*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uidskid_, uicupid_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STCupPos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STCupPos)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 uiDskId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uidskid_)));
          set_has_uidskid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiCupId;
        break;
      }

      // optional uint32 uiCupId = 2;
      case 2: {
        if (tag == 16) {
         parse_uiCupId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uicupid_)));
          set_has_uicupid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STCupPos)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STCupPos)
  return false;
#undef DO_
}

void STCupPos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STCupPos)
  // optional uint32 uiDskId = 1;
  if (has_uidskid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uidskid(), output);
  }

  // optional uint32 uiCupId = 2;
  if (has_uicupid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uicupid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STCupPos)
}

::google::protobuf::uint8* STCupPos::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STCupPos)
  // optional uint32 uiDskId = 1;
  if (has_uidskid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uidskid(), target);
  }

  // optional uint32 uiCupId = 2;
  if (has_uicupid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->uicupid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STCupPos)
  return target;
}

int STCupPos::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 uiDskId = 1;
    if (has_uidskid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uidskid());
    }

    // optional uint32 uiCupId = 2;
    if (has_uicupid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uicupid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STCupPos::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STCupPos* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STCupPos*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STCupPos::MergeFrom(const STCupPos& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uidskid()) {
      set_uidskid(from.uidskid());
    }
    if (from.has_uicupid()) {
      set_uicupid(from.uicupid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STCupPos::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STCupPos::CopyFrom(const STCupPos& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STCupPos::IsInitialized() const {

  return true;
}

void STCupPos::Swap(STCupPos* other) {
  if (other != this) {
    std::swap(uidskid_, other->uidskid_);
    std::swap(uicupid_, other->uicupid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STCupPos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STCupPos_descriptor_;
  metadata.reflection = STCupPos_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STMarginScan::kStCupPosFieldNumber;
const int STMarginScan::kUiMarginDepthFieldNumber;
#endif  // !_MSC_VER

STMarginScan::STMarginScan()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STMarginScan)
}

void STMarginScan::InitAsDefaultInstance() {
  stcuppos_ = const_cast< ::STCupPos*>(&::STCupPos::default_instance());
}

STMarginScan::STMarginScan(const STMarginScan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STMarginScan)
}

void STMarginScan::SharedCtor() {
  _cached_size_ = 0;
  stcuppos_ = NULL;
  uimargindepth_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STMarginScan::~STMarginScan() {
  // @@protoc_insertion_point(destructor:STMarginScan)
  SharedDtor();
}

void STMarginScan::SharedDtor() {
  if (this != default_instance_) {
    delete stcuppos_;
  }
}

void STMarginScan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STMarginScan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STMarginScan_descriptor_;
}

const STMarginScan& STMarginScan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STMarginScan* STMarginScan::default_instance_ = NULL;

STMarginScan* STMarginScan::New() const {
  return new STMarginScan;
}

void STMarginScan::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_stcuppos()) {
      if (stcuppos_ != NULL) stcuppos_->::STCupPos::Clear();
    }
    uimargindepth_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STMarginScan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STMarginScan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .STCupPos stCupPos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stcuppos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiMarginDepth;
        break;
      }

      // optional uint32 uiMarginDepth = 2;
      case 2: {
        if (tag == 16) {
         parse_uiMarginDepth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uimargindepth_)));
          set_has_uimargindepth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STMarginScan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STMarginScan)
  return false;
#undef DO_
}

void STMarginScan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STMarginScan)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stcuppos(), output);
  }

  // optional uint32 uiMarginDepth = 2;
  if (has_uimargindepth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uimargindepth(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STMarginScan)
}

::google::protobuf::uint8* STMarginScan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STMarginScan)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stcuppos(), target);
  }

  // optional uint32 uiMarginDepth = 2;
  if (has_uimargindepth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->uimargindepth(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STMarginScan)
  return target;
}

int STMarginScan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .STCupPos stCupPos = 1;
    if (has_stcuppos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stcuppos());
    }

    // optional uint32 uiMarginDepth = 2;
    if (has_uimargindepth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uimargindepth());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STMarginScan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STMarginScan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STMarginScan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STMarginScan::MergeFrom(const STMarginScan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stcuppos()) {
      mutable_stcuppos()->::STCupPos::MergeFrom(from.stcuppos());
    }
    if (from.has_uimargindepth()) {
      set_uimargindepth(from.uimargindepth());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STMarginScan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STMarginScan::CopyFrom(const STMarginScan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STMarginScan::IsInitialized() const {

  return true;
}

void STMarginScan::Swap(STMarginScan* other) {
  if (other != this) {
    std::swap(stcuppos_, other->stcuppos_);
    std::swap(uimargindepth_, other->uimargindepth_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STMarginScan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STMarginScan_descriptor_;
  metadata.reflection = STMarginScan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STLiquidInfo::kStCupPosFieldNumber;
const int STLiquidInfo::kUiAddVolFieldNumber;
#endif  // !_MSC_VER

STLiquidInfo::STLiquidInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STLiquidInfo)
}

void STLiquidInfo::InitAsDefaultInstance() {
  stcuppos_ = const_cast< ::STCupPos*>(&::STCupPos::default_instance());
}

STLiquidInfo::STLiquidInfo(const STLiquidInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STLiquidInfo)
}

void STLiquidInfo::SharedCtor() {
  _cached_size_ = 0;
  stcuppos_ = NULL;
  uiaddvol_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STLiquidInfo::~STLiquidInfo() {
  // @@protoc_insertion_point(destructor:STLiquidInfo)
  SharedDtor();
}

void STLiquidInfo::SharedDtor() {
  if (this != default_instance_) {
    delete stcuppos_;
  }
}

void STLiquidInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STLiquidInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STLiquidInfo_descriptor_;
}

const STLiquidInfo& STLiquidInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STLiquidInfo* STLiquidInfo::default_instance_ = NULL;

STLiquidInfo* STLiquidInfo::New() const {
  return new STLiquidInfo;
}

void STLiquidInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_stcuppos()) {
      if (stcuppos_ != NULL) stcuppos_->::STCupPos::Clear();
    }
    uiaddvol_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STLiquidInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STLiquidInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .STCupPos stCupPos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stcuppos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiAddVol;
        break;
      }

      // optional uint32 uiAddVol = 2;
      case 2: {
        if (tag == 16) {
         parse_uiAddVol:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uiaddvol_)));
          set_has_uiaddvol();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STLiquidInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STLiquidInfo)
  return false;
#undef DO_
}

void STLiquidInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STLiquidInfo)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stcuppos(), output);
  }

  // optional uint32 uiAddVol = 2;
  if (has_uiaddvol()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uiaddvol(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STLiquidInfo)
}

::google::protobuf::uint8* STLiquidInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STLiquidInfo)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stcuppos(), target);
  }

  // optional uint32 uiAddVol = 2;
  if (has_uiaddvol()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->uiaddvol(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STLiquidInfo)
  return target;
}

int STLiquidInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .STCupPos stCupPos = 1;
    if (has_stcuppos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stcuppos());
    }

    // optional uint32 uiAddVol = 2;
    if (has_uiaddvol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uiaddvol());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STLiquidInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STLiquidInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STLiquidInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STLiquidInfo::MergeFrom(const STLiquidInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stcuppos()) {
      mutable_stcuppos()->::STCupPos::MergeFrom(from.stcuppos());
    }
    if (from.has_uiaddvol()) {
      set_uiaddvol(from.uiaddvol());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STLiquidInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STLiquidInfo::CopyFrom(const STLiquidInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STLiquidInfo::IsInitialized() const {

  return true;
}

void STLiquidInfo::Swap(STLiquidInfo* other) {
  if (other != this) {
    std::swap(stcuppos_, other->stcuppos_);
    std::swap(uiaddvol_, other->uiaddvol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STLiquidInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STLiquidInfo_descriptor_;
  metadata.reflection = STLiquidInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STRctCupStatus::kUiRctCupPosFieldNumber;
const int STRctCupStatus::kEnCupStateFieldNumber;
const int STRctCupStatus::kUiRctTimesFieldNumber;
const int STRctCupStatus::kUiTaskIdFieldNumber;
const int STRctCupStatus::kStSmpPosFieldNumber;
const int STRctCupStatus::kUiDilutTypeFieldNumber;
#endif  // !_MSC_VER

STRctCupStatus::STRctCupStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STRctCupStatus)
}

void STRctCupStatus::InitAsDefaultInstance() {
  stsmppos_ = const_cast< ::STCupPos*>(&::STCupPos::default_instance());
}

STRctCupStatus::STRctCupStatus(const STRctCupStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STRctCupStatus)
}

void STRctCupStatus::SharedCtor() {
  _cached_size_ = 0;
  uirctcuppos_ = 0u;
  encupstate_ = 0;
  uircttimes_ = 0u;
  uitaskid_ = 0u;
  stsmppos_ = NULL;
  uidiluttype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STRctCupStatus::~STRctCupStatus() {
  // @@protoc_insertion_point(destructor:STRctCupStatus)
  SharedDtor();
}

void STRctCupStatus::SharedDtor() {
  if (this != default_instance_) {
    delete stsmppos_;
  }
}

void STRctCupStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STRctCupStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STRctCupStatus_descriptor_;
}

const STRctCupStatus& STRctCupStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STRctCupStatus* STRctCupStatus::default_instance_ = NULL;

STRctCupStatus* STRctCupStatus::New() const {
  return new STRctCupStatus;
}

void STRctCupStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<STRctCupStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(uirctcuppos_, uitaskid_);
    if (has_stsmppos()) {
      if (stsmppos_ != NULL) stsmppos_->::STCupPos::Clear();
    }
    uidiluttype_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STRctCupStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STRctCupStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 uiRctCupPos = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uirctcuppos_)));
          set_has_uirctcuppos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_enCupState;
        break;
      }

      // optional .CupState enCupState = 2 [default = CUP_STATE_FREE];
      case 2: {
        if (tag == 16) {
         parse_enCupState:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CupState_IsValid(value)) {
            set_encupstate(static_cast< ::CupState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_uiRctTimes;
        break;
      }

      // optional uint32 uiRctTimes = 3;
      case 3: {
        if (tag == 24) {
         parse_uiRctTimes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uircttimes_)));
          set_has_uircttimes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_uiTaskId;
        break;
      }

      // optional uint32 uiTaskId = 4;
      case 4: {
        if (tag == 32) {
         parse_uiTaskId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uitaskid_)));
          set_has_uitaskid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_stSmpPos;
        break;
      }

      // optional .STCupPos stSmpPos = 5;
      case 5: {
        if (tag == 42) {
         parse_stSmpPos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stsmppos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_uiDilutType;
        break;
      }

      // optional uint32 uiDilutType = 6;
      case 6: {
        if (tag == 48) {
         parse_uiDilutType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uidiluttype_)));
          set_has_uidiluttype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STRctCupStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STRctCupStatus)
  return false;
#undef DO_
}

void STRctCupStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STRctCupStatus)
  // optional uint32 uiRctCupPos = 1;
  if (has_uirctcuppos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uirctcuppos(), output);
  }

  // optional .CupState enCupState = 2 [default = CUP_STATE_FREE];
  if (has_encupstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->encupstate(), output);
  }

  // optional uint32 uiRctTimes = 3;
  if (has_uircttimes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->uircttimes(), output);
  }

  // optional uint32 uiTaskId = 4;
  if (has_uitaskid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->uitaskid(), output);
  }

  // optional .STCupPos stSmpPos = 5;
  if (has_stsmppos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->stsmppos(), output);
  }

  // optional uint32 uiDilutType = 6;
  if (has_uidiluttype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->uidiluttype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STRctCupStatus)
}

::google::protobuf::uint8* STRctCupStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STRctCupStatus)
  // optional uint32 uiRctCupPos = 1;
  if (has_uirctcuppos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uirctcuppos(), target);
  }

  // optional .CupState enCupState = 2 [default = CUP_STATE_FREE];
  if (has_encupstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->encupstate(), target);
  }

  // optional uint32 uiRctTimes = 3;
  if (has_uircttimes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->uircttimes(), target);
  }

  // optional uint32 uiTaskId = 4;
  if (has_uitaskid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->uitaskid(), target);
  }

  // optional .STCupPos stSmpPos = 5;
  if (has_stsmppos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->stsmppos(), target);
  }

  // optional uint32 uiDilutType = 6;
  if (has_uidiluttype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->uidiluttype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STRctCupStatus)
  return target;
}

int STRctCupStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 uiRctCupPos = 1;
    if (has_uirctcuppos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uirctcuppos());
    }

    // optional .CupState enCupState = 2 [default = CUP_STATE_FREE];
    if (has_encupstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->encupstate());
    }

    // optional uint32 uiRctTimes = 3;
    if (has_uircttimes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uircttimes());
    }

    // optional uint32 uiTaskId = 4;
    if (has_uitaskid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uitaskid());
    }

    // optional .STCupPos stSmpPos = 5;
    if (has_stsmppos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stsmppos());
    }

    // optional uint32 uiDilutType = 6;
    if (has_uidiluttype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uidiluttype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STRctCupStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STRctCupStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STRctCupStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STRctCupStatus::MergeFrom(const STRctCupStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uirctcuppos()) {
      set_uirctcuppos(from.uirctcuppos());
    }
    if (from.has_encupstate()) {
      set_encupstate(from.encupstate());
    }
    if (from.has_uircttimes()) {
      set_uircttimes(from.uircttimes());
    }
    if (from.has_uitaskid()) {
      set_uitaskid(from.uitaskid());
    }
    if (from.has_stsmppos()) {
      mutable_stsmppos()->::STCupPos::MergeFrom(from.stsmppos());
    }
    if (from.has_uidiluttype()) {
      set_uidiluttype(from.uidiluttype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STRctCupStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STRctCupStatus::CopyFrom(const STRctCupStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STRctCupStatus::IsInitialized() const {

  return true;
}

void STRctCupStatus::Swap(STRctCupStatus* other) {
  if (other != this) {
    std::swap(uirctcuppos_, other->uirctcuppos_);
    std::swap(encupstate_, other->encupstate_);
    std::swap(uircttimes_, other->uircttimes_);
    std::swap(uitaskid_, other->uitaskid_);
    std::swap(stsmppos_, other->stsmppos_);
    std::swap(uidiluttype_, other->uidiluttype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STRctCupStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STRctCupStatus_descriptor_;
  metadata.reflection = STRctCupStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STBarcodeScan::kStCupPosFieldNumber;
const int STBarcodeScan::kStrBarcodeFieldNumber;
#endif  // !_MSC_VER

STBarcodeScan::STBarcodeScan()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STBarcodeScan)
}

void STBarcodeScan::InitAsDefaultInstance() {
  stcuppos_ = const_cast< ::STCupPos*>(&::STCupPos::default_instance());
}

STBarcodeScan::STBarcodeScan(const STBarcodeScan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STBarcodeScan)
}

void STBarcodeScan::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  stcuppos_ = NULL;
  strbarcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STBarcodeScan::~STBarcodeScan() {
  // @@protoc_insertion_point(destructor:STBarcodeScan)
  SharedDtor();
}

void STBarcodeScan::SharedDtor() {
  if (strbarcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete strbarcode_;
  }
  if (this != default_instance_) {
    delete stcuppos_;
  }
}

void STBarcodeScan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STBarcodeScan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STBarcodeScan_descriptor_;
}

const STBarcodeScan& STBarcodeScan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STBarcodeScan* STBarcodeScan::default_instance_ = NULL;

STBarcodeScan* STBarcodeScan::New() const {
  return new STBarcodeScan;
}

void STBarcodeScan::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_stcuppos()) {
      if (stcuppos_ != NULL) stcuppos_->::STCupPos::Clear();
    }
    if (has_strbarcode()) {
      if (strbarcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        strbarcode_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STBarcodeScan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STBarcodeScan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .STCupPos stCupPos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stcuppos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_strBarcode;
        break;
      }

      // optional string strBarcode = 2;
      case 2: {
        if (tag == 18) {
         parse_strBarcode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strbarcode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->strbarcode().data(), this->strbarcode().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "strbarcode");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STBarcodeScan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STBarcodeScan)
  return false;
#undef DO_
}

void STBarcodeScan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STBarcodeScan)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stcuppos(), output);
  }

  // optional string strBarcode = 2;
  if (has_strbarcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strbarcode().data(), this->strbarcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strbarcode");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->strbarcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STBarcodeScan)
}

::google::protobuf::uint8* STBarcodeScan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STBarcodeScan)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stcuppos(), target);
  }

  // optional string strBarcode = 2;
  if (has_strbarcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strbarcode().data(), this->strbarcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strbarcode");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->strbarcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STBarcodeScan)
  return target;
}

int STBarcodeScan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .STCupPos stCupPos = 1;
    if (has_stcuppos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stcuppos());
    }

    // optional string strBarcode = 2;
    if (has_strbarcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strbarcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STBarcodeScan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STBarcodeScan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STBarcodeScan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STBarcodeScan::MergeFrom(const STBarcodeScan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stcuppos()) {
      mutable_stcuppos()->::STCupPos::MergeFrom(from.stcuppos());
    }
    if (from.has_strbarcode()) {
      set_strbarcode(from.strbarcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STBarcodeScan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STBarcodeScan::CopyFrom(const STBarcodeScan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STBarcodeScan::IsInitialized() const {

  return true;
}

void STBarcodeScan::Swap(STBarcodeScan* other) {
  if (other != this) {
    std::swap(stcuppos_, other->stcuppos_);
    std::swap(strbarcode_, other->strbarcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STBarcodeScan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STBarcodeScan_descriptor_;
  metadata.reflection = STBarcodeScan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STReagInfo::kStCupPosFieldNumber;
const int STReagInfo::kStrReagNameFieldNumber;
const int STReagInfo::kEnBTypeFieldNumber;
const int STReagInfo::kUiMarginDepthFieldNumber;
const int STReagInfo::kUiReTypeFieldNumber;
#endif  // !_MSC_VER

STReagInfo::STReagInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STReagInfo)
}

void STReagInfo::InitAsDefaultInstance() {
  stcuppos_ = const_cast< ::STCupPos*>(&::STCupPos::default_instance());
}

STReagInfo::STReagInfo(const STReagInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STReagInfo)
}

void STReagInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  stcuppos_ = NULL;
  strreagname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enbtype_ = 2;
  uimargindepth_ = 0u;
  uiretype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STReagInfo::~STReagInfo() {
  // @@protoc_insertion_point(destructor:STReagInfo)
  SharedDtor();
}

void STReagInfo::SharedDtor() {
  if (strreagname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete strreagname_;
  }
  if (this != default_instance_) {
    delete stcuppos_;
  }
}

void STReagInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STReagInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STReagInfo_descriptor_;
}

const STReagInfo& STReagInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STReagInfo* STReagInfo::default_instance_ = NULL;

STReagInfo* STReagInfo::New() const {
  return new STReagInfo;
}

void STReagInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<STReagInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(uimargindepth_, uiretype_);
    if (has_stcuppos()) {
      if (stcuppos_ != NULL) stcuppos_->::STCupPos::Clear();
    }
    if (has_strreagname()) {
      if (strreagname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        strreagname_->clear();
      }
    }
    enbtype_ = 2;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STReagInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STReagInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .STCupPos stCupPos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stcuppos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_strReagName;
        break;
      }

      // optional bytes strReagName = 2;
      case 2: {
        if (tag == 18) {
         parse_strReagName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_strreagname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_enBType;
        break;
      }

      // optional .BottleType enBType = 3;
      case 3: {
        if (tag == 24) {
         parse_enBType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::BottleType_IsValid(value)) {
            set_enbtype(static_cast< ::BottleType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_uiMarginDepth;
        break;
      }

      // optional uint32 uiMarginDepth = 4;
      case 4: {
        if (tag == 32) {
         parse_uiMarginDepth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uimargindepth_)));
          set_has_uimargindepth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_uiReType;
        break;
      }

      // optional uint32 uiReType = 5;
      case 5: {
        if (tag == 40) {
         parse_uiReType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uiretype_)));
          set_has_uiretype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STReagInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STReagInfo)
  return false;
#undef DO_
}

void STReagInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STReagInfo)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stcuppos(), output);
  }

  // optional bytes strReagName = 2;
  if (has_strreagname()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->strreagname(), output);
  }

  // optional .BottleType enBType = 3;
  if (has_enbtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->enbtype(), output);
  }

  // optional uint32 uiMarginDepth = 4;
  if (has_uimargindepth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->uimargindepth(), output);
  }

  // optional uint32 uiReType = 5;
  if (has_uiretype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->uiretype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STReagInfo)
}

::google::protobuf::uint8* STReagInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STReagInfo)
  // optional .STCupPos stCupPos = 1;
  if (has_stcuppos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stcuppos(), target);
  }

  // optional bytes strReagName = 2;
  if (has_strreagname()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->strreagname(), target);
  }

  // optional .BottleType enBType = 3;
  if (has_enbtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->enbtype(), target);
  }

  // optional uint32 uiMarginDepth = 4;
  if (has_uimargindepth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->uimargindepth(), target);
  }

  // optional uint32 uiReType = 5;
  if (has_uiretype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->uiretype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STReagInfo)
  return target;
}

int STReagInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .STCupPos stCupPos = 1;
    if (has_stcuppos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stcuppos());
    }

    // optional bytes strReagName = 2;
    if (has_strreagname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->strreagname());
    }

    // optional .BottleType enBType = 3;
    if (has_enbtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->enbtype());
    }

    // optional uint32 uiMarginDepth = 4;
    if (has_uimargindepth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uimargindepth());
    }

    // optional uint32 uiReType = 5;
    if (has_uiretype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uiretype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STReagInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STReagInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STReagInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STReagInfo::MergeFrom(const STReagInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stcuppos()) {
      mutable_stcuppos()->::STCupPos::MergeFrom(from.stcuppos());
    }
    if (from.has_strreagname()) {
      set_strreagname(from.strreagname());
    }
    if (from.has_enbtype()) {
      set_enbtype(from.enbtype());
    }
    if (from.has_uimargindepth()) {
      set_uimargindepth(from.uimargindepth());
    }
    if (from.has_uiretype()) {
      set_uiretype(from.uiretype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STReagInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STReagInfo::CopyFrom(const STReagInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STReagInfo::IsInitialized() const {

  return true;
}

void STReagInfo::Swap(STReagInfo* other) {
  if (other != this) {
    std::swap(stcuppos_, other->stcuppos_);
    std::swap(strreagname_, other->strreagname_);
    std::swap(enbtype_, other->enbtype_);
    std::swap(uimargindepth_, other->uimargindepth_);
    std::swap(uiretype_, other->uiretype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STReagInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STReagInfo_descriptor_;
  metadata.reflection = STReagInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STThreshold::kEnBTypeFieldNumber;
const int STThreshold::kUiThresholdFieldNumber;
#endif  // !_MSC_VER

STThreshold::STThreshold()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STThreshold)
}

void STThreshold::InitAsDefaultInstance() {
}

STThreshold::STThreshold(const STThreshold& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STThreshold)
}

void STThreshold::SharedCtor() {
  _cached_size_ = 0;
  enbtype_ = 2;
  uithreshold_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STThreshold::~STThreshold() {
  // @@protoc_insertion_point(destructor:STThreshold)
  SharedDtor();
}

void STThreshold::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STThreshold::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STThreshold::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STThreshold_descriptor_;
}

const STThreshold& STThreshold::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STThreshold* STThreshold::default_instance_ = NULL;

STThreshold* STThreshold::New() const {
  return new STThreshold;
}

void STThreshold::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    enbtype_ = 2;
    uithreshold_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STThreshold::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STThreshold)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .BottleType enBType = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::BottleType_IsValid(value)) {
            set_enbtype(static_cast< ::BottleType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiThreshold;
        break;
      }

      // optional uint32 uiThreshold = 2;
      case 2: {
        if (tag == 16) {
         parse_uiThreshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uithreshold_)));
          set_has_uithreshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STThreshold)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STThreshold)
  return false;
#undef DO_
}

void STThreshold::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STThreshold)
  // optional .BottleType enBType = 1;
  if (has_enbtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->enbtype(), output);
  }

  // optional uint32 uiThreshold = 2;
  if (has_uithreshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uithreshold(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STThreshold)
}

::google::protobuf::uint8* STThreshold::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STThreshold)
  // optional .BottleType enBType = 1;
  if (has_enbtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->enbtype(), target);
  }

  // optional uint32 uiThreshold = 2;
  if (has_uithreshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->uithreshold(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STThreshold)
  return target;
}

int STThreshold::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .BottleType enBType = 1;
    if (has_enbtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->enbtype());
    }

    // optional uint32 uiThreshold = 2;
    if (has_uithreshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uithreshold());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STThreshold::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STThreshold* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STThreshold*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STThreshold::MergeFrom(const STThreshold& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enbtype()) {
      set_enbtype(from.enbtype());
    }
    if (from.has_uithreshold()) {
      set_uithreshold(from.uithreshold());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STThreshold::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STThreshold::CopyFrom(const STThreshold& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STThreshold::IsInitialized() const {

  return true;
}

void STThreshold::Swap(STThreshold* other) {
  if (other != this) {
    std::swap(enbtype_, other->enbtype_);
    std::swap(uithreshold_, other->uithreshold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STThreshold::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STThreshold_descriptor_;
  metadata.reflection = STThreshold_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STCupADValue::kUiCupIdFieldNumber;
const int STCupADValue::kUiADPointsFieldNumber;
#endif  // !_MSC_VER

STCupADValue::STCupADValue()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STCupADValue)
}

void STCupADValue::InitAsDefaultInstance() {
}

STCupADValue::STCupADValue(const STCupADValue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STCupADValue)
}

void STCupADValue::SharedCtor() {
  _cached_size_ = 0;
  uicupid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STCupADValue::~STCupADValue() {
  // @@protoc_insertion_point(destructor:STCupADValue)
  SharedDtor();
}

void STCupADValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STCupADValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STCupADValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STCupADValue_descriptor_;
}

const STCupADValue& STCupADValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STCupADValue* STCupADValue::default_instance_ = NULL;

STCupADValue* STCupADValue::New() const {
  return new STCupADValue;
}

void STCupADValue::Clear() {
  uicupid_ = 0u;
  uiadpoints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STCupADValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STCupADValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 uiCupId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uicupid_)));
          set_has_uicupid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiADPoints;
        break;
      }

      // repeated uint32 uiADPoints = 2;
      case 2: {
        if (tag == 16) {
         parse_uiADPoints:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_uiadpoints())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_uiadpoints())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiADPoints;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STCupADValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STCupADValue)
  return false;
#undef DO_
}

void STCupADValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STCupADValue)
  // optional uint32 uiCupId = 1;
  if (has_uicupid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uicupid(), output);
  }

  // repeated uint32 uiADPoints = 2;
  for (int i = 0; i < this->uiadpoints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->uiadpoints(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STCupADValue)
}

::google::protobuf::uint8* STCupADValue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STCupADValue)
  // optional uint32 uiCupId = 1;
  if (has_uicupid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uicupid(), target);
  }

  // repeated uint32 uiADPoints = 2;
  for (int i = 0; i < this->uiadpoints_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->uiadpoints(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STCupADValue)
  return target;
}

int STCupADValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 uiCupId = 1;
    if (has_uicupid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uicupid());
    }

  }
  // repeated uint32 uiADPoints = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->uiadpoints_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->uiadpoints(i));
    }
    total_size += 1 * this->uiadpoints_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STCupADValue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STCupADValue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STCupADValue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STCupADValue::MergeFrom(const STCupADValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  uiadpoints_.MergeFrom(from.uiadpoints_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uicupid()) {
      set_uicupid(from.uicupid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STCupADValue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STCupADValue::CopyFrom(const STCupADValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STCupADValue::IsInitialized() const {

  return true;
}

void STCupADValue::Swap(STCupADValue* other) {
  if (other != this) {
    std::swap(uicupid_, other->uicupid_);
    uiadpoints_.Swap(&other->uiadpoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STCupADValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STCupADValue_descriptor_;
  metadata.reflection = STCupADValue_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STOffsetPara::kUiTypeFieldNumber;
const int STOffsetPara::kUiPosFieldNumber;
const int STOffsetPara::kUiDirFieldNumber;
const int STOffsetPara::kUiStepFieldNumber;
#endif  // !_MSC_VER

STOffsetPara::STOffsetPara()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STOffsetPara)
}

void STOffsetPara::InitAsDefaultInstance() {
}

STOffsetPara::STOffsetPara(const STOffsetPara& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STOffsetPara)
}

void STOffsetPara::SharedCtor() {
  _cached_size_ = 0;
  uitype_ = 0u;
  uipos_ = 0u;
  uidir_ = 0u;
  uistep_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STOffsetPara::~STOffsetPara() {
  // @@protoc_insertion_point(destructor:STOffsetPara)
  SharedDtor();
}

void STOffsetPara::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STOffsetPara::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STOffsetPara::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STOffsetPara_descriptor_;
}

const STOffsetPara& STOffsetPara::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STOffsetPara* STOffsetPara::default_instance_ = NULL;

STOffsetPara* STOffsetPara::New() const {
  return new STOffsetPara;
}

void STOffsetPara::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<STOffsetPara*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uitype_, uistep_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STOffsetPara::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STOffsetPara)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 uiType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uitype_)));
          set_has_uitype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiPos;
        break;
      }

      // optional uint32 uiPos = 2;
      case 2: {
        if (tag == 16) {
         parse_uiPos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uipos_)));
          set_has_uipos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_uiDir;
        break;
      }

      // optional uint32 uiDir = 3;
      case 3: {
        if (tag == 24) {
         parse_uiDir:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uidir_)));
          set_has_uidir();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_uiStep;
        break;
      }

      // optional uint32 uiStep = 4;
      case 4: {
        if (tag == 32) {
         parse_uiStep:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uistep_)));
          set_has_uistep();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STOffsetPara)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STOffsetPara)
  return false;
#undef DO_
}

void STOffsetPara::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STOffsetPara)
  // optional uint32 uiType = 1;
  if (has_uitype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uitype(), output);
  }

  // optional uint32 uiPos = 2;
  if (has_uipos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uipos(), output);
  }

  // optional uint32 uiDir = 3;
  if (has_uidir()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->uidir(), output);
  }

  // optional uint32 uiStep = 4;
  if (has_uistep()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->uistep(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STOffsetPara)
}

::google::protobuf::uint8* STOffsetPara::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STOffsetPara)
  // optional uint32 uiType = 1;
  if (has_uitype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uitype(), target);
  }

  // optional uint32 uiPos = 2;
  if (has_uipos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->uipos(), target);
  }

  // optional uint32 uiDir = 3;
  if (has_uidir()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->uidir(), target);
  }

  // optional uint32 uiStep = 4;
  if (has_uistep()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->uistep(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STOffsetPara)
  return target;
}

int STOffsetPara::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 uiType = 1;
    if (has_uitype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uitype());
    }

    // optional uint32 uiPos = 2;
    if (has_uipos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uipos());
    }

    // optional uint32 uiDir = 3;
    if (has_uidir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uidir());
    }

    // optional uint32 uiStep = 4;
    if (has_uistep()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uistep());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STOffsetPara::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STOffsetPara* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STOffsetPara*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STOffsetPara::MergeFrom(const STOffsetPara& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uitype()) {
      set_uitype(from.uitype());
    }
    if (from.has_uipos()) {
      set_uipos(from.uipos());
    }
    if (from.has_uidir()) {
      set_uidir(from.uidir());
    }
    if (from.has_uistep()) {
      set_uistep(from.uistep());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STOffsetPara::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STOffsetPara::CopyFrom(const STOffsetPara& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STOffsetPara::IsInitialized() const {

  return true;
}

void STOffsetPara::Swap(STOffsetPara* other) {
  if (other != this) {
    std::swap(uitype_, other->uitype_);
    std::swap(uipos_, other->uipos_);
    std::swap(uidir_, other->uidir_);
    std::swap(uistep_, other->uistep_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STOffsetPara::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STOffsetPara_descriptor_;
  metadata.reflection = STOffsetPara_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STDarkCurrentAD::kStAdInfoFieldNumber;
#endif  // !_MSC_VER

STDarkCurrentAD::STDarkCurrentAD()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STDarkCurrentAD)
}

void STDarkCurrentAD::InitAsDefaultInstance() {
}

STDarkCurrentAD::STDarkCurrentAD(const STDarkCurrentAD& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STDarkCurrentAD)
}

void STDarkCurrentAD::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STDarkCurrentAD::~STDarkCurrentAD() {
  // @@protoc_insertion_point(destructor:STDarkCurrentAD)
  SharedDtor();
}

void STDarkCurrentAD::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STDarkCurrentAD::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STDarkCurrentAD::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STDarkCurrentAD_descriptor_;
}

const STDarkCurrentAD& STDarkCurrentAD::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STDarkCurrentAD* STDarkCurrentAD::default_instance_ = NULL;

STDarkCurrentAD* STDarkCurrentAD::New() const {
  return new STDarkCurrentAD;
}

void STDarkCurrentAD::Clear() {
  stadinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STDarkCurrentAD::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STDarkCurrentAD)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .STKeyValue stAdInfo = 1;
      case 1: {
        if (tag == 10) {
         parse_stAdInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stadinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_stAdInfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STDarkCurrentAD)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STDarkCurrentAD)
  return false;
#undef DO_
}

void STDarkCurrentAD::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STDarkCurrentAD)
  // repeated .STKeyValue stAdInfo = 1;
  for (int i = 0; i < this->stadinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stadinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STDarkCurrentAD)
}

::google::protobuf::uint8* STDarkCurrentAD::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STDarkCurrentAD)
  // repeated .STKeyValue stAdInfo = 1;
  for (int i = 0; i < this->stadinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stadinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STDarkCurrentAD)
  return target;
}

int STDarkCurrentAD::ByteSize() const {
  int total_size = 0;

  // repeated .STKeyValue stAdInfo = 1;
  total_size += 1 * this->stadinfo_size();
  for (int i = 0; i < this->stadinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->stadinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STDarkCurrentAD::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STDarkCurrentAD* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STDarkCurrentAD*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STDarkCurrentAD::MergeFrom(const STDarkCurrentAD& from) {
  GOOGLE_CHECK_NE(&from, this);
  stadinfo_.MergeFrom(from.stadinfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STDarkCurrentAD::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STDarkCurrentAD::CopyFrom(const STDarkCurrentAD& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STDarkCurrentAD::IsInitialized() const {

  return true;
}

void STDarkCurrentAD::Swap(STDarkCurrentAD* other) {
  if (other != this) {
    stadinfo_.Swap(&other->stadinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STDarkCurrentAD::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STDarkCurrentAD_descriptor_;
  metadata.reflection = STDarkCurrentAD_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STSubVers::kUlSubsysIdFieldNumber;
const int STSubVers::kStrTimeFieldNumber;
const int STSubVers::kStrVersionsFieldNumber;
const int STSubVers::kFpgaVerFieldNumber;
#endif  // !_MSC_VER

STSubVers::STSubVers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STSubVers)
}

void STSubVers::InitAsDefaultInstance() {
}

STSubVers::STSubVers(const STSubVers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STSubVers)
}

void STSubVers::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ulsubsysid_ = 0u;
  strtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  strversions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fpgaver_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STSubVers::~STSubVers() {
  // @@protoc_insertion_point(destructor:STSubVers)
  SharedDtor();
}

void STSubVers::SharedDtor() {
  if (strtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete strtime_;
  }
  if (strversions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete strversions_;
  }
  if (this != default_instance_) {
  }
}

void STSubVers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STSubVers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STSubVers_descriptor_;
}

const STSubVers& STSubVers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STSubVers* STSubVers::default_instance_ = NULL;

STSubVers* STSubVers::New() const {
  return new STSubVers;
}

void STSubVers::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<STSubVers*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(ulsubsysid_, fpgaver_);
    if (has_strtime()) {
      if (strtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        strtime_->clear();
      }
    }
    if (has_strversions()) {
      if (strversions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        strversions_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STSubVers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STSubVers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ulSubsysId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ulsubsysid_)));
          set_has_ulsubsysid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_strTime;
        break;
      }

      // optional string strTime = 2;
      case 2: {
        if (tag == 18) {
         parse_strTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strtime()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->strtime().data(), this->strtime().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "strtime");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_strVersions;
        break;
      }

      // optional string strVersions = 3;
      case 3: {
        if (tag == 26) {
         parse_strVersions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strversions()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->strversions().data(), this->strversions().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "strversions");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_fpgaVer;
        break;
      }

      // optional uint32 fpgaVer = 4;
      case 4: {
        if (tag == 32) {
         parse_fpgaVer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fpgaver_)));
          set_has_fpgaver();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STSubVers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STSubVers)
  return false;
#undef DO_
}

void STSubVers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STSubVers)
  // optional uint32 ulSubsysId = 1;
  if (has_ulsubsysid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ulsubsysid(), output);
  }

  // optional string strTime = 2;
  if (has_strtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strtime().data(), this->strtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strtime");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->strtime(), output);
  }

  // optional string strVersions = 3;
  if (has_strversions()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strversions().data(), this->strversions().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strversions");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->strversions(), output);
  }

  // optional uint32 fpgaVer = 4;
  if (has_fpgaver()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->fpgaver(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STSubVers)
}

::google::protobuf::uint8* STSubVers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STSubVers)
  // optional uint32 ulSubsysId = 1;
  if (has_ulsubsysid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ulsubsysid(), target);
  }

  // optional string strTime = 2;
  if (has_strtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strtime().data(), this->strtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strtime");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->strtime(), target);
  }

  // optional string strVersions = 3;
  if (has_strversions()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strversions().data(), this->strversions().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strversions");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->strversions(), target);
  }

  // optional uint32 fpgaVer = 4;
  if (has_fpgaver()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->fpgaver(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STSubVers)
  return target;
}

int STSubVers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ulSubsysId = 1;
    if (has_ulsubsysid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ulsubsysid());
    }

    // optional string strTime = 2;
    if (has_strtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strtime());
    }

    // optional string strVersions = 3;
    if (has_strversions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strversions());
    }

    // optional uint32 fpgaVer = 4;
    if (has_fpgaver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fpgaver());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STSubVers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STSubVers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STSubVers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STSubVers::MergeFrom(const STSubVers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ulsubsysid()) {
      set_ulsubsysid(from.ulsubsysid());
    }
    if (from.has_strtime()) {
      set_strtime(from.strtime());
    }
    if (from.has_strversions()) {
      set_strversions(from.strversions());
    }
    if (from.has_fpgaver()) {
      set_fpgaver(from.fpgaver());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STSubVers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STSubVers::CopyFrom(const STSubVers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STSubVers::IsInitialized() const {

  return true;
}

void STSubVers::Swap(STSubVers* other) {
  if (other != this) {
    std::swap(ulsubsysid_, other->ulsubsysid_);
    std::swap(strtime_, other->strtime_);
    std::swap(strversions_, other->strversions_);
    std::swap(fpgaver_, other->fpgaver_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STSubVers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STSubVers_descriptor_;
  metadata.reflection = STSubVers_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STAlarmInfo::kUlAlarmIdFieldNumber;
const int STAlarmInfo::kUlParasFieldNumber;
const int STAlarmInfo::kStrTimeFieldNumber;
#endif  // !_MSC_VER

STAlarmInfo::STAlarmInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STAlarmInfo)
}

void STAlarmInfo::InitAsDefaultInstance() {
}

STAlarmInfo::STAlarmInfo(const STAlarmInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STAlarmInfo)
}

void STAlarmInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ulalarmid_ = 0u;
  strtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STAlarmInfo::~STAlarmInfo() {
  // @@protoc_insertion_point(destructor:STAlarmInfo)
  SharedDtor();
}

void STAlarmInfo::SharedDtor() {
  if (strtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete strtime_;
  }
  if (this != default_instance_) {
  }
}

void STAlarmInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STAlarmInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STAlarmInfo_descriptor_;
}

const STAlarmInfo& STAlarmInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STAlarmInfo* STAlarmInfo::default_instance_ = NULL;

STAlarmInfo* STAlarmInfo::New() const {
  return new STAlarmInfo;
}

void STAlarmInfo::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    ulalarmid_ = 0u;
    if (has_strtime()) {
      if (strtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        strtime_->clear();
      }
    }
  }
  ulparas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STAlarmInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STAlarmInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ulAlarmId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ulalarmid_)));
          set_has_ulalarmid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ulParas;
        break;
      }

      // repeated uint32 ulParas = 2;
      case 2: {
        if (tag == 16) {
         parse_ulParas:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_ulparas())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_ulparas())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ulParas;
        if (input->ExpectTag(26)) goto parse_strTime;
        break;
      }

      // optional string strTime = 3;
      case 3: {
        if (tag == 26) {
         parse_strTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_strtime()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->strtime().data(), this->strtime().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "strtime");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STAlarmInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STAlarmInfo)
  return false;
#undef DO_
}

void STAlarmInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STAlarmInfo)
  // optional uint32 ulAlarmId = 1;
  if (has_ulalarmid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ulalarmid(), output);
  }

  // repeated uint32 ulParas = 2;
  for (int i = 0; i < this->ulparas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->ulparas(i), output);
  }

  // optional string strTime = 3;
  if (has_strtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strtime().data(), this->strtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strtime");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->strtime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STAlarmInfo)
}

::google::protobuf::uint8* STAlarmInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STAlarmInfo)
  // optional uint32 ulAlarmId = 1;
  if (has_ulalarmid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ulalarmid(), target);
  }

  // repeated uint32 ulParas = 2;
  for (int i = 0; i < this->ulparas_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->ulparas(i), target);
  }

  // optional string strTime = 3;
  if (has_strtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->strtime().data(), this->strtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "strtime");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->strtime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STAlarmInfo)
  return target;
}

int STAlarmInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ulAlarmId = 1;
    if (has_ulalarmid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ulalarmid());
    }

    // optional string strTime = 3;
    if (has_strtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->strtime());
    }

  }
  // repeated uint32 ulParas = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->ulparas_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->ulparas(i));
    }
    total_size += 1 * this->ulparas_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STAlarmInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STAlarmInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STAlarmInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STAlarmInfo::MergeFrom(const STAlarmInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  ulparas_.MergeFrom(from.ulparas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ulalarmid()) {
      set_ulalarmid(from.ulalarmid());
    }
    if (from.has_strtime()) {
      set_strtime(from.strtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STAlarmInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STAlarmInfo::CopyFrom(const STAlarmInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STAlarmInfo::IsInitialized() const {

  return true;
}

void STAlarmInfo::Swap(STAlarmInfo* other) {
  if (other != this) {
    std::swap(ulalarmid_, other->ulalarmid_);
    ulparas_.Swap(&other->ulparas_);
    std::swap(strtime_, other->strtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STAlarmInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STAlarmInfo_descriptor_;
  metadata.reflection = STAlarmInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STTestVal::kUiCupFieldNumber;
const int STTestVal::kUiValFieldNumber;
#endif  // !_MSC_VER

STTestVal::STTestVal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STTestVal)
}

void STTestVal::InitAsDefaultInstance() {
}

STTestVal::STTestVal(const STTestVal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STTestVal)
}

void STTestVal::SharedCtor() {
  _cached_size_ = 0;
  uicup_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STTestVal::~STTestVal() {
  // @@protoc_insertion_point(destructor:STTestVal)
  SharedDtor();
}

void STTestVal::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STTestVal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STTestVal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STTestVal_descriptor_;
}

const STTestVal& STTestVal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STTestVal* STTestVal::default_instance_ = NULL;

STTestVal* STTestVal::New() const {
  return new STTestVal;
}

void STTestVal::Clear() {
  uicup_ = 0u;
  uival_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STTestVal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STTestVal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 uiCup = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uicup_)));
          set_has_uicup();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiVal;
        break;
      }

      // repeated uint32 uiVal = 2;
      case 2: {
        if (tag == 16) {
         parse_uiVal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_uival())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_uival())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uiVal;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STTestVal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STTestVal)
  return false;
#undef DO_
}

void STTestVal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STTestVal)
  // optional uint32 uiCup = 1;
  if (has_uicup()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uicup(), output);
  }

  // repeated uint32 uiVal = 2;
  for (int i = 0; i < this->uival_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->uival(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STTestVal)
}

::google::protobuf::uint8* STTestVal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STTestVal)
  // optional uint32 uiCup = 1;
  if (has_uicup()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uicup(), target);
  }

  // repeated uint32 uiVal = 2;
  for (int i = 0; i < this->uival_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->uival(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STTestVal)
  return target;
}

int STTestVal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 uiCup = 1;
    if (has_uicup()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uicup());
    }

  }
  // repeated uint32 uiVal = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->uival_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->uival(i));
    }
    total_size += 1 * this->uival_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STTestVal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STTestVal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STTestVal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STTestVal::MergeFrom(const STTestVal& from) {
  GOOGLE_CHECK_NE(&from, this);
  uival_.MergeFrom(from.uival_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uicup()) {
      set_uicup(from.uicup());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STTestVal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STTestVal::CopyFrom(const STTestVal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STTestVal::IsInitialized() const {

  return true;
}

void STTestVal::Swap(STTestVal* other) {
  if (other != this) {
    std::swap(uicup_, other->uicup_);
    uival_.Swap(&other->uival_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STTestVal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STTestVal_descriptor_;
  metadata.reflection = STTestVal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SmosData::kPrjFieldNumber;
const int SmosData::kStartPFieldNumber;
const int SmosData::kEndPFieldNumber;
const int SmosData::kOrderFieldNumber;
const int SmosData::kStartBadPFieldNumber;
const int SmosData::kEndBadPFieldNumber;
#endif  // !_MSC_VER

SmosData::SmosData()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SmosData)
}

void SmosData::InitAsDefaultInstance() {
}

SmosData::SmosData(const SmosData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SmosData)
}

void SmosData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  prj_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  startp_ = 0u;
  endp_ = 0u;
  order_ = 0u;
  startbadp_ = 0u;
  endbadp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SmosData::~SmosData() {
  // @@protoc_insertion_point(destructor:SmosData)
  SharedDtor();
}

void SmosData::SharedDtor() {
  if (prj_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prj_;
  }
  if (this != default_instance_) {
  }
}

void SmosData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SmosData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SmosData_descriptor_;
}

const SmosData& SmosData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

SmosData* SmosData::default_instance_ = NULL;

SmosData* SmosData::New() const {
  return new SmosData;
}

void SmosData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SmosData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(startp_, endbadp_);
    if (has_prj()) {
      if (prj_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        prj_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SmosData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SmosData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string prj = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_prj()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->prj().data(), this->prj().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "prj");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_startP;
        break;
      }

      // optional uint32 startP = 2;
      case 2: {
        if (tag == 16) {
         parse_startP:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startp_)));
          set_has_startp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_endP;
        break;
      }

      // optional uint32 endP = 3;
      case 3: {
        if (tag == 24) {
         parse_endP:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endp_)));
          set_has_endp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_order;
        break;
      }

      // optional uint32 order = 4;
      case 4: {
        if (tag == 32) {
         parse_order:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_startBadP;
        break;
      }

      // optional uint32 startBadP = 5;
      case 5: {
        if (tag == 40) {
         parse_startBadP:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startbadp_)));
          set_has_startbadp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_endBadP;
        break;
      }

      // optional uint32 endBadP = 6;
      case 6: {
        if (tag == 48) {
         parse_endBadP:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endbadp_)));
          set_has_endbadp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SmosData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SmosData)
  return false;
#undef DO_
}

void SmosData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SmosData)
  // optional string prj = 1;
  if (has_prj()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->prj().data(), this->prj().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "prj");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->prj(), output);
  }

  // optional uint32 startP = 2;
  if (has_startp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->startp(), output);
  }

  // optional uint32 endP = 3;
  if (has_endp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->endp(), output);
  }

  // optional uint32 order = 4;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->order(), output);
  }

  // optional uint32 startBadP = 5;
  if (has_startbadp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->startbadp(), output);
  }

  // optional uint32 endBadP = 6;
  if (has_endbadp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->endbadp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SmosData)
}

::google::protobuf::uint8* SmosData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SmosData)
  // optional string prj = 1;
  if (has_prj()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->prj().data(), this->prj().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "prj");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->prj(), target);
  }

  // optional uint32 startP = 2;
  if (has_startp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->startp(), target);
  }

  // optional uint32 endP = 3;
  if (has_endp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->endp(), target);
  }

  // optional uint32 order = 4;
  if (has_order()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->order(), target);
  }

  // optional uint32 startBadP = 5;
  if (has_startbadp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->startbadp(), target);
  }

  // optional uint32 endBadP = 6;
  if (has_endbadp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->endbadp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SmosData)
  return target;
}

int SmosData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string prj = 1;
    if (has_prj()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->prj());
    }

    // optional uint32 startP = 2;
    if (has_startp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startp());
    }

    // optional uint32 endP = 3;
    if (has_endp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endp());
    }

    // optional uint32 order = 4;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->order());
    }

    // optional uint32 startBadP = 5;
    if (has_startbadp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startbadp());
    }

    // optional uint32 endBadP = 6;
    if (has_endbadp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endbadp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SmosData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SmosData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SmosData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SmosData::MergeFrom(const SmosData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_prj()) {
      set_prj(from.prj());
    }
    if (from.has_startp()) {
      set_startp(from.startp());
    }
    if (from.has_endp()) {
      set_endp(from.endp());
    }
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_startbadp()) {
      set_startbadp(from.startbadp());
    }
    if (from.has_endbadp()) {
      set_endbadp(from.endbadp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SmosData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SmosData::CopyFrom(const SmosData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmosData::IsInitialized() const {

  return true;
}

void SmosData::Swap(SmosData* other) {
  if (other != this) {
    std::swap(prj_, other->prj_);
    std::swap(startp_, other->startp_);
    std::swap(endp_, other->endp_);
    std::swap(order_, other->order_);
    std::swap(startbadp_, other->startbadp_);
    std::swap(endbadp_, other->endbadp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SmosData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SmosData_descriptor_;
  metadata.reflection = SmosData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STAbSorbSmos::kDataFieldNumber;
#endif  // !_MSC_VER

STAbSorbSmos::STAbSorbSmos()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STAbSorbSmos)
}

void STAbSorbSmos::InitAsDefaultInstance() {
}

STAbSorbSmos::STAbSorbSmos(const STAbSorbSmos& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STAbSorbSmos)
}

void STAbSorbSmos::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STAbSorbSmos::~STAbSorbSmos() {
  // @@protoc_insertion_point(destructor:STAbSorbSmos)
  SharedDtor();
}

void STAbSorbSmos::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STAbSorbSmos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STAbSorbSmos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STAbSorbSmos_descriptor_;
}

const STAbSorbSmos& STAbSorbSmos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STAbSorbSmos* STAbSorbSmos::default_instance_ = NULL;

STAbSorbSmos* STAbSorbSmos::New() const {
  return new STAbSorbSmos;
}

void STAbSorbSmos::Clear() {
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STAbSorbSmos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STAbSorbSmos)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .SmosData data = 1;
      case 1: {
        if (tag == 10) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_data;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STAbSorbSmos)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STAbSorbSmos)
  return false;
#undef DO_
}

void STAbSorbSmos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STAbSorbSmos)
  // repeated .SmosData data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STAbSorbSmos)
}

::google::protobuf::uint8* STAbSorbSmos::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STAbSorbSmos)
  // repeated .SmosData data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STAbSorbSmos)
  return target;
}

int STAbSorbSmos::ByteSize() const {
  int total_size = 0;

  // repeated .SmosData data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STAbSorbSmos::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STAbSorbSmos* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STAbSorbSmos*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STAbSorbSmos::MergeFrom(const STAbSorbSmos& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STAbSorbSmos::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STAbSorbSmos::CopyFrom(const STAbSorbSmos& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STAbSorbSmos::IsInitialized() const {

  return true;
}

void STAbSorbSmos::Swap(STAbSorbSmos* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STAbSorbSmos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STAbSorbSmos_descriptor_;
  metadata.reflection = STAbSorbSmos_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STCupID::kIdFieldNumber;
#endif  // !_MSC_VER

STCupID::STCupID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STCupID)
}

void STCupID::InitAsDefaultInstance() {
}

STCupID::STCupID(const STCupID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STCupID)
}

void STCupID::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STCupID::~STCupID() {
  // @@protoc_insertion_point(destructor:STCupID)
  SharedDtor();
}

void STCupID::SharedDtor() {
  if (this != default_instance_) {
  }
}

void STCupID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STCupID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STCupID_descriptor_;
}

const STCupID& STCupID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STCupID* STCupID::default_instance_ = NULL;

STCupID* STCupID::New() const {
  return new STCupID;
}

void STCupID::Clear() {
  id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STCupID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STCupID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 id = 1;
      case 1: {
        if (tag == 8) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_id())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_id;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STCupID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STCupID)
  return false;
#undef DO_
}

void STCupID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STCupID)
  // repeated uint32 id = 1;
  for (int i = 0; i < this->id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->id(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STCupID)
}

::google::protobuf::uint8* STCupID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STCupID)
  // repeated uint32 id = 1;
  for (int i = 0; i < this->id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->id(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STCupID)
  return target;
}

int STCupID::ByteSize() const {
  int total_size = 0;

  // repeated uint32 id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->id(i));
    }
    total_size += 1 * this->id_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STCupID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STCupID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STCupID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STCupID::MergeFrom(const STCupID& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_.MergeFrom(from.id_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STCupID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STCupID::CopyFrom(const STCupID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STCupID::IsInitialized() const {

  return true;
}

void STCupID::Swap(STCupID* other) {
  if (other != this) {
    id_.Swap(&other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STCupID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STCupID_descriptor_;
  metadata.reflection = STCupID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int STSmpBacode::kCupnoFieldNumber;
const int STSmpBacode::kBarcodeFieldNumber;
#endif  // !_MSC_VER

STSmpBacode::STSmpBacode()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:STSmpBacode)
}

void STSmpBacode::InitAsDefaultInstance() {
}

STSmpBacode::STSmpBacode(const STSmpBacode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:STSmpBacode)
}

void STSmpBacode::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  cupno_ = 0u;
  barcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

STSmpBacode::~STSmpBacode() {
  // @@protoc_insertion_point(destructor:STSmpBacode)
  SharedDtor();
}

void STSmpBacode::SharedDtor() {
  if (barcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete barcode_;
  }
  if (this != default_instance_) {
  }
}

void STSmpBacode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* STSmpBacode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return STSmpBacode_descriptor_;
}

const STSmpBacode& STSmpBacode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_upmsgstruct_2eproto();
  return *default_instance_;
}

STSmpBacode* STSmpBacode::default_instance_ = NULL;

STSmpBacode* STSmpBacode::New() const {
  return new STSmpBacode;
}

void STSmpBacode::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    cupno_ = 0u;
    if (has_barcode()) {
      if (barcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        barcode_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool STSmpBacode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:STSmpBacode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 cupno = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cupno_)));
          set_has_cupno();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_barcode;
        break;
      }

      // optional string barcode = 2;
      case 2: {
        if (tag == 18) {
         parse_barcode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_barcode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->barcode().data(), this->barcode().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "barcode");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:STSmpBacode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:STSmpBacode)
  return false;
#undef DO_
}

void STSmpBacode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:STSmpBacode)
  // optional uint32 cupno = 1;
  if (has_cupno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->cupno(), output);
  }

  // optional string barcode = 2;
  if (has_barcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->barcode().data(), this->barcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "barcode");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->barcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:STSmpBacode)
}

::google::protobuf::uint8* STSmpBacode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:STSmpBacode)
  // optional uint32 cupno = 1;
  if (has_cupno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->cupno(), target);
  }

  // optional string barcode = 2;
  if (has_barcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->barcode().data(), this->barcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "barcode");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->barcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:STSmpBacode)
  return target;
}

int STSmpBacode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 cupno = 1;
    if (has_cupno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cupno());
    }

    // optional string barcode = 2;
    if (has_barcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->barcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void STSmpBacode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const STSmpBacode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const STSmpBacode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void STSmpBacode::MergeFrom(const STSmpBacode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cupno()) {
      set_cupno(from.cupno());
    }
    if (from.has_barcode()) {
      set_barcode(from.barcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void STSmpBacode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void STSmpBacode::CopyFrom(const STSmpBacode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STSmpBacode::IsInitialized() const {

  return true;
}

void STSmpBacode::Swap(STSmpBacode* other) {
  if (other != this) {
    std::swap(cupno_, other->cupno_);
    std::swap(barcode_, other->barcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata STSmpBacode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = STSmpBacode_descriptor_;
  metadata.reflection = STSmpBacode_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
